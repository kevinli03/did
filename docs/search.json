[
  {
    "objectID": "did.html",
    "href": "did.html",
    "title": "Basics of DiD",
    "section": "",
    "text": "What is DiD?\nDifference-in-differences (DiD) is a causal identification strategy that can help us estimate causal effects, and go from correlation to causation.\nFor an example, let us consider the famous paper by Card and Kreuger (1993).\n\nContext: New Jersey increased its minimum wage in April of 1992.\nQuestion: How did raising the minimum wage affect the employment rates at fast-food restaurants?\n\nWe have data on employment rates in New Jersey in March 1992, before the minimum wage increase, and data from December 1992, after the minimum wage increase. The data looks like this:\n\n\n\n\n\n\n\n\n\nBased on this data, it might be tempting to say something like this:\n\nThe employment rate in December 1992 is 4 units higher than than the employment rate in March. Thus, the causal effect of the minimum wage increase is 4 units.\n\nHowever, this would be the wrong conclusion. Why? Well something could have happened between March and December. Perhaps there was a giant country-wide economic boom which caused the increase in employment, which had nothing to do with minimum wage in New Jersey.\nDifference-in-differences is a solution to this problem. DiD tells us too look at another state - a state that did not receive the treatment. Nearby Pennsylvania did not increase its minimum wage during this time period. Let us see how their employment rate is doing:\n\n\n\n\n\n\n\n\n\nPennsylvania gives us the trend in employment rate if no minimum wage increase occurred. We then make an assumption - had New Jersey not undergone a minimum wage increase, it would have followed the same trend in employment rates.\n\n\n\n\n\n\n\n\n\nThus, difference-in-differences allows us to estimate the causal effect of a treatment by looking at the trend of an untreated unit, and using that trend to approximate what would have happened if the treatment never occurred.\n\n\n\nParallel Trends Assumption\nThe key assumption behind DiD is the parallel trends assumption - that indeed, New Jersey would have followed the same trend as Pennsylvania, had New Jersey not had the minimum wage increase. Or in the figures above, that New Jersey would have indeed followed the dotted purple line trend if it had not had a minimum wage increase.\nMore generally, the parallel trends assumption says that if the treated units had been hypothetically untreated, they would have followed the same trend in the outcome variable as the untreated units.\nWhat can go wrong when parallel trends is violated? Consider the same example above, but somehow, we were able to magically see what really happened to New Jersey without a minimum wage increase. Let us pretend that New Jersey alone (and not Pennsylvania) suffered from some mighty economic crash.\n\n\n\n\n\n\n\n\n\nWe can see that in this scenario, the true New Jersey trend (solid purple) is not parallel to the Pennsylvania trend. Thus, if we were to assume the Pennsylvania trend on the New Jersey trend (dotted purple), our estimate of the causal effect would be wrong.\nHow do we check the parallel trends assumption? Unfortunately, it is impossible to actually check it, since it involves a hypothetical outcome (New Jersey not getting the minimum wage increase).\nHowever, we often test for parallel trends in the years before the treatment starts (pre-treatment periods). The idea is that if there are parallel trends for several years before the start of treatment, then it is likely to continue into the treatment period.\nWe can also control for covariates (other variables) that we believe might cause violations in parallel trends. Typically covariates that cause violations of parallel trends are:\n\nCorrelated with the outcome variable.\nHave different trends in the untreated and treated groups.\n\n\n\n\nATT and Dynamic Effects\nThe main causal effect of interest in DiD is the average treatment effect on the treated (ATT). This is the causal effect of treatment on units that receive the treatment.\n\nImportant! This is not the same as the average treatment effect (ATE). That applies to all units, including untreated units. The ATT only applies to treated units, and cannot easily be generalised to untreated units.\n\nWe are often also interested in what is called dynamic treatment effects. These are essentially ATT estimates for every year in our data.\nFor example, let us say that after New Jersey legalised minimum wage, we continued to observe the employment rates for the next 5 years (as well as those in Pennsylvania). We can then create dynamic treatment effects for each of the next 5 years - which will help us visualise how the treatment effects change over time.\nDynamic treatment effects are also not only limited to the post-treatment period. If we had data before the treatment took place, we could also calculate dynamic treatment effects for each period. This is useful because we can use this to test for parallel trends.\nThis is because we shouldn’t expect the treatment and control groups to differ in their pre-treatment trends if parallel trends is met, and thus, the treatment effect should be 0 or close to 0 in the pre-treatment period. if this is not the case, then we have evidence that parallel trends is violated.\n\n\n\nStaggered and Absorbing\nDiD designs can be categorised by two factors: if treatment is staggered and if treatment is absorbing.\nNon-staggered treatment means all units that receive the treatment in our study receive it at the same time. For example, in our New Jersey example, all fast food restaurants in New Jersey experienced the minimum wage rise at the same time.\nStaggered treatment means units start treatment at different times in our study. This is often the case when we are studying multiple states - where some states begin some treatment earlier than others.\nAbsorbing treatment means units who get treated, always remain treated for the rest of our study. For example, in our New Jersey example, all fast food restaurants in New Jersey who got the minimum wage rise, remained with the higher minimum wage.\nNon-Absorbing treatment means units who get treated might return to being untreated. For example, this could happen if New Jersey decides a few years later to lower the minimum wage back to its original level.\nThese terms will become important when we explore the issues with two-way fixed effects, and why econometricians have spent 2021-onwards trying to solve those issues.",
    "crumbs": [
      "Basics of DiD"
    ]
  },
  {
    "objectID": "twfe.html",
    "href": "twfe.html",
    "title": "Two-Way Fixed Effects",
    "section": "",
    "text": "What is TWFE?\nTwo-way fixed effects (TWFE) is the primary estimator used to estimate causal effects in difference-in-differences. The TWFE estimator is a regression model specified as follows:\n\\[\nY_{it} = \\underbrace{\\alpha_i + \\gamma_t}_\\text{fixed effects} + D_{it}\\tau + \\cov + \\eps_{it}\n\\]\n\n\\(Y_{it}\\) is the outcome, \\(D_{it}\\) is the treatment, \\(\\b X_{it}\\) is a vector of covariates (optional) for parallel trends, and \\(\\tau\\) is the causal effect.\n\nFor dynamic treatment effects, the TWFE model is estimated as:\n\\[\nY_{it} = \\underbrace{\\alpha_i + \\gamma_t}_\\text{fixed effects} + \\sum_{r ≠ -1} 1\\{R_{it} = r\\} \\cdot \\tau_r + \\eps_{it}\n\\]\n\n\\(R_{it}\\) is a relative-time variable, that is equal to the time period \\(t\\) minus the initial treatment period of unit \\(i\\). \\(1\\{R_{it}=r\\}\\) is an indicator variable that equals 1 if \\(R_{it} = r\\), and 0 otherwise.\n\nFixed effect \\(\\alpha_i\\) accounts/controls for differences between units, and \\(\\gamma_t\\) accounts/controls for differences between time periods. If we account for differences between units and differences between time periods, the only possible confounders remaining are unit-specific trends over time. But with the parallel trends assumption, we rule out this type of confounder.\nThus, under the parallel trends assumption, there are no omitted confounders/variables, and our regression is exogenous. Since OLS is unbiased under exogeneity, our TWFE estimator for \\(\\tau\\) is unbiased.\n\n\n\nIssues with TWFE\nTWFE has been shown to be a biased estimator (bad estimator) for the ATT and dynamic treatment effects when dealing with staggered treatment implementation. So when units begin treatment at different times, TWFE is biased.\nWhy is this? Goodman-Bacon (2021) shows that in a staggered setting, TWFE is actually a weighted average of 4 comparisons:\n\nEarly-treated units vs. untreated units.\nLate-treated units vs. untreated units.\nEarly-treated units vs. late-treated units before treatment.\nEarly-treated units after treatment vs. late-treated units before and after treatment.\n\nWhen we compare treatment to control, we want to compare treated to untreated units. The issue comes with the 4th comparison - we actually use late-treated units after receiving treatment as a untreated comparison. This is called the “forbidden comparison” problem of TWFE.\nDe Chaisemartin and D’Haultœuille (2020) show that there is another problem with TWFE - the weighting of these comparisons when aggregating these comparisons. For an accurate average treatment effect on the treated (ATT), we in theory want to weight each comparison by the proportion of the sample size each comparison contains. For example, if more units are in the early-treated units, we would want to weight that comparison more.\nThe issue with TWFE is that not only does it not weight by group size, it doesn’t even always give positive weights. In fact, sometimes, TWFE will assign negative weights to certain comparisons. This is completely nonsensical, and has been shown to even reverse the sign of the true ATT in simulations.\nThus, TWFE is a biased estimator when it comes to staggered treatment designs. Since 2021, Econometricians have started developing modern estimators that resolve the issues with TWFE.\n\nBrantly Callaway has a more detailed page on the issues with TWFE. Pedro Sant’Anna also has a powerpoint on the Bacon-Goodman decomposition.\n\n\n\n\nR: Setting Up the Data\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nunit\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ntreat\nTreatment variable for each observation. Should equal 1 for treated units and 0 for untreated units.\n\n\nrel.time\nA relative time variable that indicates for the given period \\(t\\) of an observation, how many time-periods away did the unit \\(i\\) first get the treatment. For the never-treated observations, set the value to a very large or small number (-1000 is a common choice).\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the unit variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the unit variable.\n\n\n\n\n\n\n\nCreating a rel.time Variable\n\n\n\n\n\nTo create a rel.time variable if your dataset does not have one, we first need to create a first.treat variable, which indicates the period that a unit first gets treated.\n\nlibrary(tidyverse)\n\n# create first.treat\nfirst.treat &lt;- df %&gt;%\n  select(treat, time, unit) %&gt;%\n  filter(treat == 1) %&gt;%\n  group_by(unit) %&gt;%\n  summarise(first.treat = min(time))\n\n# join first.treat to df\ndf &lt;- left_join(df, first.treat)\n\nNow, we can create a rel.time variable:\n\ndf$rel.time &lt;- df$time - df$first.treat\n\n# now set our never-treated rel.time values to a super large or small num\ndf$rel.time &lt;- replace_na(df$rel.time, -1000)\n\n\n\n\n\n\n\nR: Estimating the ATT\nWe use the fixest package to run a TWFE model:\n\nlibrary(fixest)\n\natt &lt;- feols(\n  fml   = outcome ~ treat + covar | unit + time,  # covariate is optional\n  data  = df,                                     # your data\n  vcov  = ~unit                                   # cluster SE by unit\n)\n\nsummary(att)\n\n#&gt; OLS estimation, Dep. Var.: outcome\n#&gt; Observations: 950\n#&gt; Fixed-effects: unit: 95,  time: 10\n#&gt; Standard-errors: Clustered (unit) \n#&gt;       Estimate Std. Error  t value  Pr(&gt;|t|)    \n#&gt; treat -3.68310   0.361071 -10.2005 &lt; 2.2e-16 ***\n#&gt; covar  1.01833   0.032416  31.4142 &lt; 2.2e-16 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; RMSE: 1.60906     Adj. R2: 0.691054\n#&gt;                 Within R2: 0.623425\n\n\nThe coefficient of treat is our estimate of the ATT - the causal effect of treatment on those who receive the treatment. The significance is given by Pr(&gt;|t|) (the p-value) and the stars *** .\n\n\n\n\n\n\nExtracting ATT Directly\n\n\n\n\n\nIf you need to extract the att directly (to create tables or graphs), we can use the coef() function in the fixest package:\n\ncoef(att)\n\n#&gt;     treat     covar \n#&gt; -3.683101  1.018332\n\n\nThis is a table, so we can subset the treatment coefficient directly to extract it.\n\ncoef(att)[1]\n\n#&gt;     treat \n#&gt; -3.683101\n\n\nWe can also directly extract confidence intervals in a similar way.\n\nconfint(att)\n\n#&gt;            2.5 %    97.5 %\n#&gt; treat -4.4000165 -2.966186\n#&gt; covar  0.9539689  1.082695\n\n\nThis is a table, so we can subset the treatment coefficient directly to extract it.\n\nconfint(att)[1,1]\nconfint(att)[1,2]\n\n#&gt; [1] -4.400017\n#&gt; [1] -2.966186\n\n\n\n\n\n\n\n\nR: Estimating Dynamic Effects\nWe use the fixest package to run a TWFE model for dynamic effects:\n\nlibrary(fixest)\n\ndynamic &lt;- feols(\n  fml   = outcome ~ i(rel.time, ref = c(-1, -1000)) + covar | unit + time,\n  # Do not change -1 in c(). You change -1000 to the value of never-treated for rel.time\n  \n  data  = df,     # your data\n  vcov  = ~unit   # cluster SE by unit\n)\n\n# summary(dynamic) if you want to find the actual values of coefficients\n\nWe can plot these results.\n\nlibrary(ggfixest)\nlibrary(ggplot2)\n\nplot &lt;- ggiplot(\n  # required options\n  object   = dynamic,           # input your dynamic model object\n  ref.line = FALSE,             # we will add our own line later\n  \n  # optional aesthetic options\n  xlab     = \"Time Relative to Treatment\",  # x-axis label\n  ylab     = \"Dynamic ATT Estimate\",        # y-axis label\n  main     = \"Dynamic Treatment Effects\",   # title for plot\n)\n\nplot +\n  # select how many period to display\n  xlim(-8, 8) +\n  \n  # add reference lines for treatment beginning and 0 causal effect\n  geom_vline(xintercept = -0.5, linetype = 3) +\n  geom_hline(yintercept = 0, linetype = 3, color = \"red\") +\n  \n  # ggplot theme (optional, change to your liking)\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\nHere we can see all of our dynamic treatment effects plotted. We can split the dynamic treatment effects into 2 groups for interpretation purposes.\n\nPre-treatment (before the white dotted line). If parallel trends assumption is met, then the confidence intervals of the estimates should cover 0 (the red line).\n\n\nIn this example, we can see evidence that parallel trends is violated.\n\n\nPost-treatment (after the white dotted line). These coefficients represent the treatment effect over time. If their confidence intervals do not include 0, that means the treatment effect is significant.\n\n\nIn this example, we can see the initial post-treatment periods have negative effects, but this becomes positive as the years go on.",
    "crumbs": [
      "Two-Way Fixed Effects"
    ]
  },
  {
    "objectID": "sunab.html",
    "href": "sunab.html",
    "title": "1  Interaction-Weighted",
    "section": "",
    "text": "Sun and Abraham (2021)\n\n\nWhat is the IW Estimator?\nThe Interaction-Weighted (IW) estimator, also known as sunab, is an estimator for DiD that solves the issues with TWFE in staggered settings. The estimator was proposed by Sun and Abraham (2021).\nIW is a matching and reweighting estimator for DiD, with the matching part solving the “forbidden comparisons” problem of TWFE, and the reweighting part solving the “negative weighting” problem of TWFE.\nFirst, the IW estimator “matches” treated units to control units in correct non-forbidden comparisons. It does this by separating all treated units into groups, grouped by their initial treatment year. Then, for group, IW compares treated vs. untreated for every year. This “matching” is done via interactions in regression:\n\\[\nY_{it} = \\underbrace{\\alpha_i + \\gamma_t}_\\text{fixed effects} + \\underbrace{\\sum_g \\sum_{r ≠ -1} 1\\{G_i = g\\} \\cdot 1\\{R_{it} = r\\} \\cdot \\tau_{gr}}_\\text{comparisons for each group g and rel.time r} + \\cov + \\eps_{it}\n\\]\n\n\\(G_i\\) is a categorical variable that describes which initial treatment period unit \\(i\\) received treatment. \\(R_{it}\\) is a relative-time variable. Essentially, IW is estimating dynamic treatment effects for each initial treatment period group \\(g\\).\n\nThis matching will produce many different comparison estimates \\(\\tau_{gr}\\). These \\(\\tau_{gr}\\) are reweighted together, with weights determined by how many observations fall into each group \\(g\\) and relative time period \\(r\\). The \\(\\tau_{gr}\\) can be aggregated into the overall ATT, Dynamic ATT’s with all groups combined together, and the overall ATT for each group \\(g\\) separately.\nIW does not accommodate non-absorbing treatment. IW is also less flexible with covariates for parallel trends, since the linear model assumes a linear relationship between covariates and outcome (which might not always be realistic).\n\n\n\nR: Running the Model\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nunit\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\nfirst.treat\nThis variable indicates the initial year of treatment adoption for each unit. For the never-treated, we should set the value of first.treat to a very large positive/negative value that is outside the range of time.\n\n\n\n\n*For repeated cross-section, the unit variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the unit variable.\n\n\n\n\n\n\n\nCreating a first.treat Variable\n\n\n\n\n\nIf your dataset lacks a first.treat variable, this is how you create one, using the other variables above.\n\nlibrary(tidyverse)\n\n# create first.treat\nfirst.treat &lt;- df %&gt;%\n  select(treat, time, unit) %&gt;%\n  filter(treat == 1) %&gt;%\n  group_by(unit) %&gt;%\n  summarise(first.treat = min(time))\n\n# join first.treat to df\ndf &lt;- left_join(df, first.treat)\n\n# replace NA's (never-treated) in first.treat with big number\ndf$first.treat &lt;- replace_na(df$first.treat, 10000)\n\n\n*For repeated cross-section, the unit variable should be instead the group/level of which treatment is assigned. The treat variable should also be grouped by the same group/level.\n\n\n\n\nWith all the proper variables, we can estimate a IW model with the fixest package:\n\nlibrary(fixest)\n\niw &lt;- feols(\n  fml = outcome ~\n          sunab(first.treat, time) + covar | unit + time,\n  data = df,\n  vcov = ~unit\n)\n\nThis model has now done the matching and estimating \\(\\tau_{gr}\\). We now can choose different ways to aggregate these.\n\n\n\nR: Aggregating the ATT\nTo aggregate the matched treatment effects \\(\\tau_{gr}\\) into a singular ATT causal estimate for all treated observations, we can use the aggregate() function:\n\natt &lt;- aggregate(\n  x   = iw,    # IW model object\n  agg = \"att\"  # output the ATT\n)\n\nprint(att)\n\n#&gt;      Estimate Std. Error   t value     Pr(&gt;|t|)\n#&gt; ATT -1.133749  0.2050705 -5.528584 2.882038e-07\n\n\nWe can see the estimated ATT in the output table, as well as the estimated p-value in Pr(&gt;|t|).\n\n\n\n\n\n\nExtract the ATT Directly\n\n\n\n\n\nIf you are interested in extracting the ATT and confidence intervals directly from the att object for tables/figures, you can do the following:\n\natt &lt;- as.data.frame(att)\n\n# extract att\natt[1,1]\n\n# extract std. error\natt[1,2]\n\n#&gt; [1] -1.133749\n#&gt; [1] 0.2050705\n\n\n\nThis can be useful if you are making a graph/table comparing different estimators.\n\n\n\n\n\n\n\nR: Aggregating Dynamic Effects\nWe can plot the dynamic treatment effects using the IW object estimated when running the model:\n\nlibrary(ggfixest)\nlibrary(ggplot)\n\nplot &lt;- ggiplot(\n  # required options\n  object   = iw,                # input your original iw model\n  ref.line = FALSE,             # we will add our own line later\n  \n  # (optional) aesthetic options\n  xlab     = \"Time Relative to Treatment\",       # x-axis label\n  ylab     = \"Dynamic ATT Estimate\",             # y-axis label\n  main     = \"Dynamic Treatment Effects (IW)\",   # title for plot\n)\n\nplot +\n  # select how many period to display\n  xlim(-8, 8) +\n  \n  # add reference lines for treatment beginning and 0 causal effect\n  geom_vline(xintercept = -0.5, linetype = 3) +\n  geom_hline(yintercept = 0, linetype = 3, color = \"red\") +\n  \n  # ggplot theme (optional, change to your liking)\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinding Exact Dynamic Coefficient Values\n\n\n\n\n\nIf you want exact dynamic coefficient values (to see or for a table), we have to use the aggregate command\n\ndynamic &lt;- aggregate(\n  x   = iw,       # IW model object\n  agg = \"period\"  # output the dynamic effects\n)\n\nhead(dynamic) # print(dynamic) to see all the coefficient values\n\n#&gt;             Estimate Std. Error    t value  Pr(&gt;|t|)\n#&gt; time::-9  0.35176562  0.3590732  0.9796487 0.3297742\n#&gt; time::-8 -0.07900914  0.2974701 -0.2656036 0.7911262\n#&gt; time::-7  0.10104016  0.3669646  0.2753403 0.7836591\n#&gt; time::-6 -0.05640239  0.3089161 -0.1825816 0.8555195\n#&gt; time::-5 -0.29530929  0.2939543 -1.0046095 0.3176640\n#&gt; time::-4 -0.30372133  0.2491128 -1.2192120 0.2258144\n\n\n\n\n\n\n\n\nR: Aggregating Group ATT\nIf we are interested in how the ATT differs by year of treatment adoption, we can also aggregate effects by initial treatment period group:\n\ngroup &lt;- aggregate(\n  x   = iw,       # IW model object\n  agg = \"cohort\"  # output the dynamic effects\n)\n\n# print(group) if you want to see the exact group-ATT numbers\n\nThere isn’t a quick way to immediately plot these estimates, but we can manually create a ggplot:\n\nlibrary(tidyverse)\n\n# make group a df\ngroup &lt;- as.data.frame(group)\n\n# add cohort period to group df\ngroup$period &lt;- rownames(group)\ngroup$period &lt;- as.factor(group$period)\n\n# calculate lower and upper conf intervals\ngroup$lower &lt;- group$Estimate - 1.96*group$`Std. Error`\ngroup$upper &lt;- group$Estimate + 1.96*group$`Std. Error`\n\n# ggplot\nggplot(data = group, aes(x = Estimate, y = period)) +\n  # vertical line at 0 treatment effect\n  geom_vline(xintercept = 0, color = \"red\", linetype = 3) +\n  \n  # plot the treatment effects\n  geom_point(color = \"blue\") +\n  \n  # plot the confidence intervals\n  geom_linerange(aes(xmin = lower, xmax = upper), width = 0.2, color = \"blue\") +\n  \n  # title (optional)\n  labs(title = \"Treatment Effects by Initial Treatment Period\") +\n\n  # x-axis and y-axis labels (optional)\n  xlab(\"Estimated ATT (IW)\") + ylab(\"Initial Treatment Period\") +\n  \n  # theme (optional, change to your liking)\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdditional Resources\nSun, L. and Abraham S. (2021) ‘Estimating Dynamic Treatment Effects in Event studies with Heterogenous Treatment Effects’, Journal of Econometrics, 225(2), pp. 175-199. Available at: https://arxiv.org/abs/1804.05785\nAdditional Links:\n\nFixest documentation for sunab() function.\nFixest documentation for aggregate() function.\nAsjad Naqvi page on sunab.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Interaction-Weighted</span>"
    ]
  },
  {
    "objectID": "csdid.html",
    "href": "csdid.html",
    "title": "2  Doubly-Robust",
    "section": "",
    "text": "Callaway and Sant’Anna (2021)\n\n\nWhat is csdid?\nThe doubly-robust DiD estimator, also called csdid, is an estimator for DiD that solves the issues with TWFE in staggered settings. The estimator was proposed by Callaway and Sant’Anna (2021).\ncsdid is a matching and reweighting estimator for DiD, with the matching part solving the “forbidden comparisons” problem of TWFE, and the reweighting part solving the “negative weighting” problem of TWFE.\nFirst, the csdid estimator “matches” treated units to control units in correct non-forbidden comparisons. It does this by separating all treated units into groups, grouped by their initial treatment year. Then, it compares each group to the never-treated units, calculating dynamic effects \\(\\tau_{g,t}\\) for each group. These dynamic effects \\(\\tau_{g,t}\\) are calculated with a combination of regression-adjustment and inverse probability weighting (hence the “double” in doubly robust).\nThese \\(\\tau_{g,t}\\) are reweighted together, with weights determined by how many observations fall into each group \\(g\\) and time period \\(t\\). The \\(\\tau_{g,t}\\) can be aggregated into the overall ATT, Dynamic ATT’s with all groups combined together, and the overall ATT for each group \\(g\\) separately.\ncsdid does not accommodate non-absorbing treatment. Because it is semi-parametric (with the inverse probability weighting), csdid is more flexible with dealing with covariates than the interaction-weighted estimator.\n\n\n\nR: Running the Model\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nunit\nA variable indicating the units/individual an observation belongs to in our data.* For csdid, this must be integers.\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\nfirst.treat\nThis variable indicates the initial year of treatment adoption for each unit. For the never-treated, we should set the value of first.treat to a very large positive/negative value that is outside the range of time.\n\n\n\n\n*For repeated cross-section, the unit variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the unit variable.\n\n\n\n\n\n\n\nCreating a first.treat Variable\n\n\n\n\n\nIf your dataset lacks a first.treat variable, this is how you create one, using the other variables above.\n\nlibrary(tidyverse)\n\n# create first.treat\nfirst.treat &lt;- df %&gt;%\n  select(treat, time, unit) %&gt;%\n  filter(treat == 1) %&gt;%\n  group_by(unit) %&gt;%\n  summarise(first.treat = min(time))\n\n# join first.treat to df\ndf &lt;- left_join(df, first.treat)\n\n# replace NA's (never-treated) in first.treat with big number\ndf$first.treat &lt;- replace_na(df$first.treat, 10000)\n\n\n*For repeated cross-section, the unit variable should be instead the group/level of which treatment is assigned. The treat variable should also be grouped by the same group/level.\n\n\n\n\nNote for csdid, the unit variable must be an integer, not a character variable. You can ensure it is an integer with the following code:\n\ndf$unit &lt;- as.integer(as.factor(df$unit))\n\nWith all the proper variables, we can estimate a csdid model with the did package:\n\nlibrary(did)\n\ncsdid &lt;- att_gt(\n  # required arguments\n  yname                  = \"outcome\",\n  tname                  = \"time\",\n  idname                 = \"unit\",          # must be a integer-variable\n  gname                  = \"first.treat\",\n  base_period            = 'universal',     # do not change\n  allow_unbalanced_panel = T,               # generally good to keep this T\n  data                   = df,\n  \n  # optional arguments\n  xformla                = ~covar,          # you may have difficulties with covariates\n  control_group          = \"nevertreated\"   # use \"notyettreated\" if sample size is small\n)\n\nThis model has now done the matching and estimating \\(\\tau_{g,t}\\). We now can choose different ways to aggregate these.\n\n\n\nR: Aggregating the ATT\nTo aggregate the matched treatment effects \\(\\tau_{g,t}\\) into a singular ATT causal estimate for all treated observations, we can use the aggte() function:\n\natt &lt;- aggte(\n  MP    = csdid,     # model from att_gt\n  type  = \"simple\",  # this tells R aggregate for ATT\n  na.rm = T\n)\n\nsummary(att)\n\n#&gt; \n#&gt; Call:\n#&gt; aggte(MP = csdid, type = \"simple\", na.rm = T)\n#&gt; \n#&gt; Reference: Callaway, Brantly and Pedro H.C. Sant'Anna.  \"Difference-in-Differences with Multiple Time Periods.\" Journal of Econometrics, Vol. 225, No. 2, pp. 200-230, 2021. &lt;https://doi.org/10.1016/j.jeconom.2020.12.001&gt;, &lt;https://arxiv.org/abs/1803.09015&gt; \n#&gt; \n#&gt; \n#&gt;      ATT    Std. Error     [ 95%  Conf. Int.]  \n#&gt;  -1.1237        0.4969    -2.0976     -0.1498 *\n#&gt; \n#&gt; \n#&gt; ---\n#&gt; Signif. codes: `*' confidence band does not cover 0\n#&gt; \n#&gt; Control Group:  Never Treated,  Anticipation Periods:  0\n#&gt; Estimation Method:  Doubly Robust\n\n\n\n\n\n\n\n\nExtract the ATT Directly\n\n\n\n\n\nIf you are interested in extracting the ATT and confidence intervals directly from the att object for tables/figures, you can do the following:\n\natt$overall.att\n\n#&gt; [1] -1.123719\n\n\nTo extract the standard errors, we do the following:\n\natt$overall.se\n\n#&gt; [1] 0.4968901\n\n\n\n\n\n\n\n\nR: Aggregating Dynamic Effects\nWe can estimate dynamic treatment effects with the aggte function:\n\ndynamic &lt;- aggte(\n  MP    = csdid,      # model from att_gt\n  type  = \"dynamic\",  # this tells R aggregate for dynamic effects\n  na.rm = T\n)\n\n# summary(dynamic) if you want to see the exact dynamic effect numbers\n\nWe can then plot these effects with the ggdid package included in the did package:\n\ngraph &lt;- ggdid(\n  # required arguments\n  object = dynamic,              # input your object from aggte\n  \n  # optional arguments\n  xlab   = \"Time to Treatment\",  # x-axis label\n  ylab   = \"Dynamic ATT\",        # y-axis label\n  title  = \"Dynamic Effects\"     # you can include a title string if you want\n) \n\ngraph + geom_vline(xintercept = -0.5, linetype = 3) # line at treat time\n\n\n\n\n\n\n\n\n\n\n\n\n\nR: Aggregating Group ATT\nIf we are interested in how the ATT differs by year of treatment adoption, we can also aggregate effects by initial treatment period group:\n\ngroup &lt;- aggte(\n  MP    = csdid,    # model from att_gt\n  type  = \"group\",  # this tells R aggregate for dynamic effects\n  na.rm = T\n)\n\n# summary(group) if you want to see the exact group-ATT numbers\n\nWe can then plot these effects with the ggdid function included in the did package:\n\nggdid(\n  # required arguments\n  object = group,           # input your object from aggte\n  \n  # optional arguments\n  xlab   = \"ATT Estimate\",  # x-axis label\n  ylab   = \"Group\",         # y-axis label\n  title  = \"Group ATT\"      # you can include a title string if you want\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nR: Heterogeneity Across Time\nWe can also explore how treatment effects change over calendar time (not relative time, but actual time).\n\ntime &lt;- aggte(\n  MP    = csdid,       # model from att_gt\n  type  = \"calendar\",  # this tells R aggregate for dynamic effects\n  na.rm = T\n)\n\n# summary(group) if you want to see the exact group-ATT numbers\n\nWe can then plot these effects with the ggdid function included in the did package:\n\nggdid(\n  # required arguments\n  object = time,               # input your object from aggte\n  \n  # optional arguments\n  xlab   = \"Time Period\",      # x-axis label\n  ylab   = \"Estimate\",         # y-axis label\n  title  = \"Calendar Effects\"  # you can include a title string if you want\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdditional Resources\nCallaway, B. and Sant’Anna, P. H. C. (2021) ‘Difference-in-Differences with multiple time periods’, Journal of Econometrics, 225(2), pp. 200-230. Available at: https://psantanna.com/files/Callaway_SantAnna_2020.pdf.\nAdditional Links:\n\nLong vignette on the issues with TWFE and the csdid framework.\ndid package documentation for att_gt().\ndid package documentation for aggte().\ndid package documentation for ggdid().\nAsjad Naqvi page on did.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Doubly-Robust</span>"
    ]
  },
  {
    "objectID": "didmultiple.html",
    "href": "didmultiple.html",
    "title": "3  DIDmultiple",
    "section": "",
    "text": "De Chaisemartin and D’Haultfœuille (2020, 2024)\n\n\nWhat is DIDmultiple?\nThe DIDMultiple estimator, also called csdid, is an estimator for DiD that solves the issues with TWFE in staggered settings. It also expands DiD to work with continuous treatments and non-absorbing treatments. The estimator was proposed by de Chaisemartin and D’Haultfœuille (2020, 2024).\nDIDmultiple is a matching and reweighting estimator for DiD, with the matching part solving the “forbidden comparisons” problem of TWFE, and the reweighting part solving the “negative weighting” problem of TWFE.\nThe estimator focuses on switchers - those units in a certain period who change their treatment status. For example, a unit that goes from \\(D_{it} = 0\\) to \\(D_{it} = 1\\). DIDmultiple “matches” these switchers to the group that does not switch (so the group of units that stay \\(D_{it} = 0\\)), and estimates the difference in outcomes. In a binary treatment setting, the treatment effect at period \\(\\tau_t\\) can be described as:\n\\[\n\\tau_t = \\frac{\\mathbb E[\\Delta Y |\\text{switchers}] - \\mathbb E[\\Delta Y |\\text{non-switchers}]}{\\underbrace{\\mathbb E[\\Delta D |\\text{switchers}]}_\\text{=1 if absorbing treatment}}\n\\]\n\nThis might seem similar to those familar with IV-wald estimator, and in fact, this is a Wald estimator, called Wald-TC.\n\nThen, DIDmultiple aggregates these effects of switchers by reweighting them properly. This can be used to estimate both a singular ATT and dynamic effects. The focus on switchers allows DIDmultiple to be applied onto non-binary treatments, including continuous treatments.\n\n\n\nR: Running the Model\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nunit\nA variable indicating the units/individual an observation belongs to in our data.* For csdid, this must be integers.\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the unit variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the unit variable.\n\nWith all the proper variables, we can estimate a DIDmultiple model with the DIDmultiplegtDYN package:\n\nlibrary(DIDmultiplegtDYN)\n\nWarning: package 'DIDmultiplegtDYN' was built under R version 4.4.1\n\nDIDmultiple &lt;- did_multiplegt_dyn(\n  # required arguments\n  df         = df,\n  outcome    = \"outcome\",\n  group      = \"unit\",    # Note: group here refers to unit, not first.treat\n  time       = \"time\",\n  treatment  = \"treat\",\n  effects    = 4,         # Number of post-treatment periods dynamic effects\n  placebo    = 4,         # Number of pre-treatment periods of effects\n  \n  # optional arguments\n  controls   = NULL,      # optional, vector of covariates. I have difficulties.\n  continuous = NULL,      # change to 1 if your treatment is true\n  graph_off  = T\n)\n\nThe model has now been run, and we can now output the effects or plot the effects.\n\n\n\nR: Output the Effects\nWe can output the effects from a DIDmultiple model as follows:\n\nprint(DIDmultiple)\n\n#&gt; \n#&gt; ----------------------------------------------------------------------\n#&gt;        Estimation of treatment effects: Event-study effects\n#&gt; ----------------------------------------------------------------------\n#&gt;              Estimate SE      LB CI    UB CI    N   Switchers\n#&gt; Effect_1     -5.04943 0.45371 -5.93869 -4.16017 675 45       \n#&gt; Effect_2     -3.25734 0.49253 -4.22269 -2.29199 580 40       \n#&gt; Effect_3     -2.17826 0.54482 -3.24609 -1.11044 490 35       \n#&gt; Effect_4     -0.03749 0.50608 -1.02940 0.95442  405 30       \n#&gt; \n#&gt; Test of joint nullity of the effects : p-value = 0.0000\n#&gt; ----------------------------------------------------------------------\n#&gt;     Average cumulative (total) effect per treatment unit\n#&gt; ----------------------------------------------------------------------\n#&gt;  Estimate        SE     LB CI     UB CI         N Switchers \n#&gt;  -2.89921   0.38159  -3.64711  -2.15131       780       150 \n#&gt; Average number of time periods over which a treatment effect is accumulated: 2.3333\n#&gt; \n#&gt; ----------------------------------------------------------------------\n#&gt;      Testing the parallel trends and no anticipation assumptions\n#&gt; ----------------------------------------------------------------------\n#&gt;              Estimate SE      LB CI    UB CI   N   Switchers\n#&gt; Placebo_1    0.27204  0.49208 -0.69242 1.23651 580 40       \n#&gt; Placebo_2    -0.72910 0.61928 -1.94287 0.48467 405 30       \n#&gt; Placebo_3    -0.27729 0.55098 -1.35720 0.80262 250 20       \n#&gt; Placebo_4    0.00895  1.00786 -1.96642 1.98433 115 10       \n#&gt; \n#&gt; Test of joint nullity of the placebos : p-value = 0.5860\n#&gt; \n#&gt; \n#&gt; The development of this package was funded by the European Union.\n#&gt; ERC REALLYCREDIBLE - GA N. 101043899\n\n\nThis output contains quite a lot of material.\n\nThe first section are dynamic treatment effects for post-treatment periods.\nThe second section is the average cumulative effect per treatment unit, also equivalent to the ATT in a binary setting.\nThe final section contains pre-treatment effects, which can help us determine if parallel trends is met. The joint-nullity test of the placebos should be non-significant if parallel trends is met.\n\n\n\n\n\n\n\nExtracting ATT Estimates\n\n\n\n\n\nWe can extract the ATT directly for plots or figures with the following:\n\n# ATE\nDIDmultiple$results$ATE[1]\n\n# Standard Error\nDIDmultiple$results$ATE[2]\n\n# Lower confidence interval\nDIDmultiple$results$ATE[3]\n\n# Upper confidence interval\nDIDmultiple$results$ATE[4]\n\n#&gt; [1] -2.89921\n#&gt; [1] 0.38159\n#&gt; [1] -3.64711\n#&gt; [1] -2.15131\n\n\n\n\n\n\n\n\nR: Plotting Dynamic Effects\nThe DIDmultiple model automatically generates a ggplot. We can make a few modifications to the plot:\n\nlibrary(ggplot2)\n\n# assign plot to plot object\nplot &lt;- DIDmultiple$plot\n\n# get rid of weird line in degault plot\nplot$layers[[1]] &lt;- NULL\n\n# customise plot\nplot +\n  # title and axis-labels\n  labs(title = \"Dynamic Treatment Effects\") +\n  xlab(\"Time to Treatment (t=1)\") + ylab(\"Estimate\") +\n  \n  # lines for treatment time and 0 treatment effect\n  geom_vline(xintercept = 0.5, linetype = 3) +\n  geom_hline(yintercept = 0, linetype = 3, color = \"red\") +\n  \n  # Theme\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdditional Resources\nde Chaisemartin, C. and D’Haultfœuille, X (2024) ‘Difference-in-Differences Estimators of Intertemporal Treatment Effects’, The Review of Economics and Statistics, pp. 1-45. Available at: https://doi.org/10.1162/rest_a_01414.\nde Chaisemartin, C. and D’Haultfœuille, X (2020) ‘Two-Way Fixed Effects Estimators with Heterogenous Treatment Effects’, American Economic Review, 110(9), pp. 2964-2996. Available at: https://www.nber.org/system/files/working_papers/w25904/w25904.pdf.\nAdditional Links:\n\nAsjad Naqvi’s page on DIDmultipleDYN.\nYiqing Xu’s section on DIDmultiple.\nDIDmultiplegtDYN package documentation.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>DIDmultiple</span>"
    ]
  },
  {
    "objectID": "panelmatch.html",
    "href": "panelmatch.html",
    "title": "4  PanelMatch",
    "section": "",
    "text": "Imai, Kim, and Wang (2023)\n\n\nWhat is PanelMatch\nPanelMatch is an estimator for DiD that solves the issues with TWFE in staggered settings. It also accomodates non-absorbing treatment. The estimator was proposed by Imai, Kim, and Wang (2023).\nPanelMatch is a matching and reweighting estimator for DiD, with the matching part solving the “forbidden comparisons” problem of TWFE, and the reweighting part solving the “negative weighting” problem of TWFE.\nFirst, the PanelMatch estimator “matches” treated units to control units in correct non-forbidden comparisons. For every treated unit \\(D_{it}=1\\) in a specific time period \\(t\\), PanelMatch finds a group of untreated units \\(D_{it} = 0\\) in the same time period, that have identical past treatment history in a set number of previous treatment periods.\n\nThe number of pre-treatment history to match on is called the lag period. For example, if lag = 4, then treated units are matched to untreated units with the same treatment history in the 4 periods before this period. Lag is typically between 3 and 5.\n\nThen, PanelMatch compares the outcome of the treated unit compared to the weighted average of the matched untreated units. When there are no covariates, each matched untreated unit is weighted equally in this weighted average. When there are covariates, weighting depends on the mahalanobis distance of covariates.\nThis comparison produces a series of treatment effect estimates (one for each treated unit). These are then properly aggregated together to find the causal effects.\n\nIf the lag period of matching for pre-treatment is exactly 1, and we only estimate effects for the first post-treat period, then PanelMatch is equivalent to DIDmultiple.\n\nBecause of its design, PanelMatch can function properly when there is non-absorbing treatment. Disadvantages revolve on the need for exact pre-treatment history matching, which might not be possible in some datasets.\n\n\n\nR: Running the Model\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nunit\nA variable indicating the units/individual an observation belongs to in our data.* For PanelMatch, this must be integers.\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the unit variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the unit variable.\n\nPanelMatch requires unit to be an integer variable. We can change a non-integer unit into an integer by:\n\ndf$unit &lt;- as.integer(as.factor(df$unit))\n\nBefore starting estimation, PanelMatch requires us to pre-process the data.\n\nlibrary(PanelMatch)\n\n# PanelMatch dislikes tidyverse df's, so do this:\ndf &lt;- as.data.frame(df)\n\ndf.panel &lt;- PanelData(\n  panel.data = df,        # your data\n  unit.id    = \"unit\",    # your unit var (integer only)\n  time.id    = \"time\",    # your time period var (integer only)\n  treatment  = \"treat\",   # your treatment var\n  outcome    = \"outcome\"  # your outcome var\n)\n\nNow, we can run the PanelMatch matching process:\n\nmatch = PanelMatch(\n  # required arguments\n  lag               = 4,              # number of pre-periods to match treat history\n  panel.data        = df.panel,       # PanelData generated data\n  lead              = c(0:3),         # how many post-treat dynamic effects to estimate\n  qoi               = \"att\",\n  refinement.method = \"mahalanobis\",  # set to \"none\" if no covaraites\n  match.missing     = T,\n  \n  # optional arguments\n  covs.formula      = ~ covar,        # (optional, can exclude)\n  placebo.test      = T               # (optional, but may cause issues)\n)\n\nNow the matching process is complete, and aggregating the effects is now possible.\n\n\n\nR: Aggregating the ATT\nTo aggregate all the matched comparisons into a singular ATT, we use the PanelEstimate() function.\n\natt = PanelEstimate(\n  # required arguments\n  sets       = match,     # PanelMatch object\n  panel.data = df.panel,  # PanelData object\n  pooled     = T,         # tells R to calculate ATT\n  \n  # optional arguments\n  moderator  = NULL       # (\"string\") var to calculate heterogenous effects\n)\n\nprint(att)\n\n#&gt; Point estimates:\n#&gt; [1] -3.617353\n#&gt; Standard errors:\n#&gt; [1] 0.6099269\n\n\n\n\n\n\n\n\nExtract the ATT Directly\n\n\n\n\n\nIf you are interested in extracting the ATT and standard errors directly from the att object for tables/figures, you can do the following:\n\natt$estimate\natt$standard.error\n\n#&gt; [1] -3.617353\n#&gt; [1] 0.6099269\n\n\n\n\n\n\n\n\nR: Aggregating Dynamic Effects\nWe can estimate dynamic treatment effects with the PanelEstimate() function:\n\ndynamic = PanelEstimate(\n  sets       = match,     # PanelMatch object\n  panel.data = df.panel,  # PanelData object\n  pooled     = F          # tells R to calculate dynamic effects\n)\n\nsummary(dynamic)\n\n#&gt;       estimate std.error      2.5%      97.5%\n#&gt; t+0 -5.5516448 0.8627789 -7.465616 -4.0658651\n#&gt; t+1 -4.7163024 0.6571119 -6.124894 -3.6322600\n#&gt; t+2 -3.3294543 0.7745523 -4.911283 -1.9380456\n#&gt; t+3 -0.8720093 0.8763570 -2.629651  0.7532462\n\n\nThe above function only estimates post-treatment dynamic effects. We can graph these using the plot() function:\n\nplot = plot(\n  x    = dynamic,               # object from PanelEstimate\n  ylab = \"Estimate\",            # y-axis label\n  xlab = \"Time to Treatment\",   # x-axis label\n  main = \"Dynamic Effects\"      # title of plot\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nR: Placebo Tests\nWe can conduct pre-treatment period placebo tests (pre-treatment effects to test for parallel trends) as well. These are done with the placebo_test() function.\n\npre = placebo_test(\n  pm.obj     = match,     # PanelMatch object\n  panel.data = df.panel,  # PanelData object\n  lag.in     = 4,         # should equal lag in PanelMatch()\n  plot       = T\n)\n\n\n\n\n\n\n\n\n\n\n\nAdditional Resources\nImai, K., Kim, I. S., and Wang, E. (2023) ‘Matching Methods for Causal Inference with Time-Series Cross-Sectional Data’, American Journal of Political Science, 67(3), pp. 587-605. Available at: https://imai.fas.harvard.edu/research/tscs.html.\nAdditional Links:\n\nPackage documentation for PanelMatch.\nYiqing Xu’s section on PanelMatch.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>PanelMatch</span>"
    ]
  },
  {
    "objectID": "fect.html",
    "href": "fect.html",
    "title": "5  Imputation",
    "section": "",
    "text": "Liu, Xu, and Wang (2024)\n\n\nWhat is Imputation?\nThe Imputation method, also known as the fixed-effects counterfactual estimator (FEct), is an estimator for DiD that solves the issues with TWFE in staggered settings. The estimator also accomodates non-absorbing treatment. The estimator was proposed by Liu, Xu, and Wang (2024). The same approach is also proposed by Borusyak, Jaravel, and Spiess (2021).\n\nI will only use the fect package from Liu, Xu, and Wang (2024), not the DIDimputation package from Borusyak, Jaravel, and Spiess (2021), or the did2s package from Gardner (2021). These do almost the identical thing, but fect has additional estimators and tools that make it more useful.\n\nFor treated units \\(D_{it} = 1\\), the potential outcome \\(Y_{it}(0)\\) is a counterfactual we do not observe. Imputation estimators try to estimate \\(Y_{it}(0)\\), which allows us to compute individual treatment effects \\(\\tau_i\\) and find the ATT. FEct estimates \\(Y_{it}(0)\\) for treated units by using the following model:\n\\[\nY_{it}(0) = \\underbrace{\\alpha_i + \\gamma_t}_\\text{fixed effects} + \\cov + \\eps_{it}\n\\]\n\nThis is literally a TWFE model with \\(D_{it} = 0\\), which is the case for potential outcome \\(Y_{it}(0)\\).\n\nImputation estimators will use OLS to estimate \\(\\hat\\alpha_i\\), \\(\\hat\\gamma_t\\), and \\(\\hat{\\b\\beta}\\), using only untreated observations \\(D_{it} = 0\\). Using these estimates, we can estimate missing counterfactuals \\(\\hat Y_{it}(0)\\). There are three versions of imputation estimators:\n\nFEct (fixed effects counterfactual): this is what is described above.\nIFEct (interactive fixed effects counterfactual): This is the above model for \\(Y_{it}(0)\\), but with the inclusion of a term \\(\\b\\lambda_i' \\b\\xi_t\\). The \\(\\b\\xi_t\\) is a vector of latent variable that change over time, and \\(\\b\\lambda_i\\) is a vector of how much each unit is related to each latent variable. More simply, this allows IFEct to be more robust to minor parallel trends violations.\nMC (matrix completion). This is a more machine-learning based approach of estimating \\(Y_{it}(0)\\) that does not rely on the fixed-effects specification.\n\nYou should generally run a FEct model first - and check if parallel trends are met. If parallel trends are violated, you should test IFEct and MC and see if parallel trends are met in those estimators.\n\n\n\nR: Estimating the ATT\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nunit\nA variable indicating the units/individual an observation belongs to in our data.* For csdid, this must be integers.\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the unit variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the unit variable.\n\nWith all the proper variables, we can estimate a FEct model with the fect package. As noted in the “what is imputation” section, we can choose between three methods: “fe”, “ife”, and “mc”.\n\nlibrary(fect)\n\nfect &lt;- fect(\n  # required arguments\n  formula = outcome ~ treat + covar,  # covar is optional\n  data    = df,\n  index   = c(\"unit\", \"time\"),        # unit and time var\n  method  = \"fe\",                     # use \"fe\", \"ife\", or \"mc\"\n  \n  # optional arguments\n  se      = T,                        # F means no estimated std error - much quicker\n  nboots  = 40,                       # usually you should use 200, larger is slower\n  seed    = 1239                      # any number. for replication\n)\n\nprint(fect)\n\n#&gt; Call:\n#&gt; fect.formula(formula = outcome ~ treat + covar, data = df, index = c(\"unit\", \n#&gt;     \"time\"), method = \"fe\", se = T, nboots = 40, seed = 1239)\n#&gt; \n#&gt; ATT:\n#&gt;                              ATT   S.E. CI.lower CI.upper   p.value\n#&gt; Tr obs equally weighted   -1.091 0.4746   -2.022  -0.1611 2.148e-02\n#&gt; Tr units equally weighted -2.964 0.5814   -4.104  -1.8246 3.432e-07\n#&gt; \n#&gt; Covariates:\n#&gt;        Coef    S.E. CI.lower CI.upper p.value\n#&gt; covar 1.004 0.02042   0.9643    1.044       0\n\n\nThe output contains two different ATT estimates. It is typically conventional to use the first one, Tr obs equally weighted, which weights each observation \\(it\\) equally (rather than the second which weights all \\(i\\) equally).\n\n\n\n\n\n\nExtract the ATT Directly\n\n\n\n\n\nWe can access the dataframe where the ATT and standard errors are stored as follows:\n\nfect$est.avg\n\n#&gt;        ATT.avg      S.E.  CI.lower   CI.upper    p.value\n#&gt; [1,] -1.091429 0.4746486 -2.021723 -0.1611347 0.02147962\n\n\nThus, we can subset and retrieve the elements of this dataframe:\n\n# ATT estimate\nfect$est.avg[1]\n\n# Lower confidence interval\nfect$est.avg[3]\n\n# Upper confidence interval\nfect$est.avg[4]\n\n#&gt; [1] -1.091429\n#&gt; [1] -2.021723\n#&gt; [1] -0.1611347\n\n\n\n\n\n\n\n\nR: Estimating Dynamic Effects\nThe FEct package allows quick aggregation of dynamic effects through plotting. The plot is a ggplot object, if you want to change or make additions to it.\n\nlibrary(ggplot2)\n\nplot(\n  # required arguments\n  x      = fect,                         # our output object from fect()\n  start0 = T,                            # don't change\n  \n  # optional aesthetic arguments\n  main   = \"Dynamic Treatment Effects\",  # title\n  ylab   = \"Estimate\",                   # y-axis label\n  xlab   = \"Time to Treatment\",          # x-axis label\n  xlim   = c(-7, 7)                      # what time periods to include (offset by +1)\n)\n\n\n\n\n\n\n\n\n\n\nNote the bars below - it shows the number of observations of units who ever receive treatment in each time period.\nThe fect package also allows us to conduct some pretty cool parallel trends tests, but that is for a later section.\n\n\n\nR: Treatment Heterogeneity\nFEct allows us to make some pretty cool graphs that allow us to explore treatment heterogeneity. First, we can explore how treatment effects change over calendar time (not relative time, but actual time). This is somewhat similar to the “grouped” ATT treatment effects of the matching and reweighting estimators.\n\nplot(\n  # required arguments\n  x      = fect,                          # our output object from fect()\n  start0 = T,                             # don't change\n  \n  # optional aesthetic arguments\n  type   = \"calendar\",                    # don't change\n  main   = \"Calendar Treatment Effects\",  # title\n  ylab   = \"Estimate\",                    # y-axis label\n  xlab   = \"Time Period\",                 # x-axis label\n  xlim   = c(1, 10)                       # what time periods to include (offset by +1)\n)\n\n\n\n\n\n\n\n\n\n\nThe red-line shows the overall ATT estimate. The highlighted area is the confidence intervals of the heterogeneous treatment effects over time.\n\n\n\nR: Individual Treatment Effects\nWe can also explore the distributions of individual treatment effects by relative time period:\n\nplot(\n  # required arguments\n  x      = fect,                            # our output object from fect()\n  start0 = T,                               # don't change\n  \n  # optional aesthetic options\n  type   = \"box\",                           # don't change\n  main   = \"Individual Treatment Effects\",  # title\n  ylab   = \"Estimate\",                      # y-axis label\n  xlab   = \"Time to Treatment\",             # x-axis label\n  xlim   = c(-7, 7)                         # what time periods to include (offset by +1)\n  \n)\n\n\n\n\n\n\n\n\n\n\nThe fect package also allows us to conduct some pretty cool parallel trends tests, but that is for a later section.\n\n\n\nAdditional Resources\nLiu, L., Wang, Y., and Xu, Y. (2024) ‘A Practical Guide to Counterfactual Estimators for Causal Inference with Time-Series Cross-Sectional Data’, American Journal of Political Science, 68(1), pp. 160-176. Available at: https://yiqingxu.org/papers/english/2022_fect/LWX2022.pdf\nBorusyak, K., Jaravel, X., and Spiess, J. (2024) ‘Revisiting Event-Study Designs: Robust and Efficient Estimation’, The Review of Economic Studies, 91(6), pp. 3253-3285. Available at: https://arxiv.org/abs/2108.12419.\nAdditional Links\n\nYiqing Xu’s page on Fect.\nYiqing Xu’s page on Fect plot options.\nR-documentation of the fect package.\n\nMore on Other Imputation Estimators\n\nKyle Butts’ github page on DIDimputation.\nKyle Butts’ github page on did2s.\nAsjad Naqvi’s github page on did2s.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Imputation</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Difference-in-Differences (DiD) Resources",
    "section": "",
    "text": "Welcome!\nThis repository is a collection of resources on Difference-in-Differences (DiD). This repository includes:\n\nA basic overview of DiD, including how it works, and the assumptions. A look at the TWFE estimator in classic DiD.\nA series of modern estimators that address issues with TWFE, including a brief description/vignette and R-code.\nA series of additional tests/visualisations useful for DiD.\n\nThis is a work in progress, and I am updating it constantly. If there are any issues, please contact me - details found on my personal github page.\n\n\n\nAdditional Resources\n\n\n\nResource\nAuthor\nNotes\n\n\n\n\nYiqing Xu: modern advancements in DiD\nYiqing Xu\nUseful overview of all modern DiD methods and R code.\n\n\nAsjad Naqvi: repository on DiD\nAsjad Naqvi\nUseful R and state code for DiD.\n\n\nUser Guides for DiD\nBrantly Callaway\nUseful guides and explanations of DiD with R.\n\n\nLecture: Problems with TWFE\nPedro Sant’Anna\nBacon decomposition and introduction to csdid.\n\n\nCausal Inference: The Mixtape\nScott Cunningham\nTextbook chapter introducing DiD.\n\n\nChiu et al (2025)\nChiu et al\nPaper exploring new DiD methods and reanalysing old polisci papers.\n\n\nRoth et al (2025)\nRoth et al\nAn overview of new DiD methods.\n\n\nLiu et al (2025)\nLiu et al\nAn overview of imputation DiD methods.\n\n\n\n\n\n\nAcknowledgements\nThis repository was created to help me collect all that I had learned about DiD together into one place. I hope this can be helpful for others.\nI would like to thank the following individuals for teaching me so much about DiD and causal inference during my Master’s degree at LSE:\n\nDr. Daniel de Kadt\nDr. Aliz Toth",
    "crumbs": [
      "Welcome!"
    ]
  }
]