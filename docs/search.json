[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Difference-in-Differences (DiD) Resources",
    "section": "",
    "text": "Welcome!\nThis repository is a collection of resources on Difference-in-Differences (DiD) and implementation in R. This repository contains instructions for the implementation of the main DiD estimators, as well as a few R packages useful for DiD.\nLectures on DiD (from my lectures on causal inference):\n\nExogeneity (Background for DiD and causal inference)\nPotential Outcomes (Background for DiD and causal inference)\nClassical DiD\nGeneralised DiD\nStaggered DiD\nExtensions to DiD\n\n\n\n\nTypes of DiD\n\n\n\n\n\n\n\n\n\nNon-Staggered\nStaggered\n\n\nAbsorbing\nAll units that get treatment begin treatment in the same period.\nOnce a unit is treated, they remain treated for the duration of the study.\nUnits that get treatment begin treatment in different periods (staggered adoption).\nOnce a unit is treated, they remain treated for the duration of the study.\n\n\nNon Absorbing\nAll units that get treatment begin treatment in the same period.\nA treated unit may become untreated after already receiving the treatment.\nUnits that get treatment begin treatment in different periods (staggered adoption).\nA treated unit may become untreated after already receiving the treatment.\n\n\n\n\n\n\nIdentification Assumptions\nFor a quick review, these are the identification assumptions for DiD.\n\n\n\n\n\n\n\n\nAssumption\nDescription\nTesting/Dealing With\n\n\n\n\nParallel Trends Assumption\nHad the treated group not received the treatment, they would have followed the same trend in outcomes as the never-treated group.\nWe can test parallel trends by looking at pre-treatment dynamic treatment effects. If the pre-treatment effects are significantly different than 0, that is evidence against parallel trends.\nWe can address this using conditional parallel trends - parallel trends met when conditioning on covariates with differing trends.\n\n\nNo Anticipation\nThe treated group’s outcome variables do not respond to treatment before treatment officially begins.\nTesting is done theoretically.\nWe address this by altering the treatment variable (move forward/backward) to match the anticipation structure.\n\n\nStable Unit Treatment Value (SUTVA)\nOne unit’s treatment status does not affect the potential outcomes of another unit.\nTesting is done theoretically.\nVery little can be done to address this.\n\n\nStable Group Composition\n(Repeated cross-section only). The sample from each time period is consistent in terms of composition of confounders.\nTesting can be done with balance tests.\nWe can address this issue by controlling for confounders that differ between different samples.\n\n\n\n\n\n\nAdditional Resources\n\n\n\nResource\nAuthor\nNotes\n\n\n\n\nYiqing Xu: modern advancements in DiD\nYiqing Xu\nUseful overview of all modern DiD methods and R code.\n\n\nAsjad Naqvi: repository on DiD\nAsjad Naqvi\nUseful R and state code for DiD.\n\n\nUser Guides for DiD\nBrantly Callaway\nUseful guides and explanations of DiD with R.\n\n\nLecture: Problems with TWFE\nPedro Sant’Anna\nBacon decomposition and introduction to csdid.\n\n\nCausal Inference: The Mixtape\nScott Cunningham\nTextbook chapter introducing DiD.\n\n\nChiu et al (2025)\nChiu et al\nPaper exploring new DiD methods and reanalysing old polisci papers.\n\n\nRoth et al (2025)\nRoth et al\nAn overview of new DiD methods.\n\n\nLiu et al (2025)\nLiu et al\nAn overview of imputation DiD methods.\n\n\n\n\n\n\nAcknowledgements\nThis repository was created to help me collect all that I had learned about DiD together into one place. I hope this can be helpful for others.\nI would like to thank the following individuals for teaching me so much about DiD and causal inference during my Master’s degree at LSE:\n\nDr. Daniel de Kadt\nDr. Aliz Toth",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "panelview.html",
    "href": "panelview.html",
    "title": "panelView",
    "section": "",
    "text": "visualisations for DiD and panel analysis\n\npanelView is a package that focuses on visualising panel treatment data over time. panelView can:\n\nVisaulise treatment adoption over time, allowing us to see if treatment adoption is staggered, and if treatment is absorbing.\nVisualise outcome values over time (or any variable).\n\n\n# packages needed: \nlibrary(panelView)\n\n\npanelView can help us visualise treatment adoption over time, allowing us to see if treatment adoption is staggered, and if treatment is absorbing.\n\nSyntaxVariables\n\n\nWe use the panelview() function to create the visualisation.\n\npanelview(\n  # required options\n  data        = df,\n  formula     = outcome ~ treat,  # only include these two\n  type        = \"treat\",          # don't change\n  index       = c(\"id\", \"time\"),\n  \n  # optional options\n  gridOff     = T,\n  background  = \"white\",\n  main        = \"Treatment Status\",\n  xlab        = \"Time Period\",\n  ylab        = \"Unit\",\n  cex.axis.y  = 2\n)\n\n\n\n\n\n\n\n\nWe can see here, that our treatment is staggered, with the first group receiving treatment in time period 2, and some units receiving treatment in every subsequent period.\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ntreat\nTreatment variable for each observation. Should equal 1 for treated units and 0 for untreated units.\n\n\n\n\n\n\n\npanelView can also help us visualise variable values over time. Most frequently, we will visualise outcome values over time, but you can also test covariate values over time.\n\nSyntaxVariables\n\n\nWe use the panelview() function to create the visualisation.\n\npanelview(\n  # required options\n  data          = df,\n  formula       = outcome ~ treat,  # change to outcome ~ 1 to ignore treat colorcoding\n  type          = \"outcome\",        # don't change\n  index         = c(\"id\", \"time\"),\n  pre.post      = F,                # you can try T and see which you like  \n  outcome.type  = \"continuous\",     # change to \"discrete\" if outcome is binary\n  \n  # optional options\n  gridOff       = T,\n  background    = \"white\",\n  main          = \"Treatment Status\",\n  xlab          = \"Time Period\",\n  ylab          = \"Outcome Values\",\n  cex.axis.y    = 2\n)\n\n\n\n\n\n\n\n\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ntreat\nTreatment variable for each observation. Should equal 1 for treated units and 0 for untreated units.\n\n\n\n\n\n\n\nAdditional Resources\n\nSee the tutorial of panelView.\nSee the documentation of panelView.",
    "crumbs": [
      "panelView"
    ]
  },
  {
    "objectID": "twfe.html",
    "href": "twfe.html",
    "title": "twfe (fixest)",
    "section": "",
    "text": "non-staggered, absorbing, binary treatment\n\nThe two-way fixed effects (TWFE) estimator is the standard estimator used for DiD. The model takes the following form.\n\\[\nY_{it} = \\underbrace{\\hat\\alpha_i + \\hat\\delta_t}_\\text{fixed effects} + D_{it}\\hat\\tau  + \\mathbf X_{it}^\\top\\hat{\\b\\beta} + \\hat\\eps_{it}\n\\]\nThe idea is that unit fixed effects \\(\\alpha_i\\) account for between-unit differences, and time fixed effects \\(\\delta_t\\) account for between-period differences. Thus, the only remaining confounders are varying-trends, which are assumed to not be present due to the parallel trends assumption.\nThe TWFE \\(\\hat\\tau\\) estimate is an unbiased esitmator of the ATT if treatment is non-staggered and absorbing, and the identification assumptions hold.\nTWFE can be severely biased if there is staggered treatment or non-absorbing treatment. Details are further explained here.\n\n# packages needed: \nlibrary(fixest)\nlibrary(ggfixest)\n\n\n\nSyntaxVariables\n\n\nWe use the feols() function to run the TWFE model.\n\nmod = feols(\n  fml   = outcome ~ treat + covar | id + time,  # covariate is optional\n  data  = df,                                   # your data\n  vcov  = ~ id                                  # cluster SE by unit\n)\n\nmod |&gt; summary()\n\n#&gt; OLS estimation, Dep. Var.: outcome\n#&gt; Observations: 950\n#&gt; Fixed-effects: id: 95,  time: 10\n#&gt; Standard-errors: Clustered (id) \n#&gt;       Estimate Std. Error  t value  Pr(&gt;|t|)    \n#&gt; treat -3.68310   0.361071 -10.2005 &lt; 2.2e-16 ***\n#&gt; covar  1.01833   0.032416  31.4142 &lt; 2.2e-16 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; RMSE: 1.60906     Adj. R2: 0.691054\n#&gt;                 Within R2: 0.623425\n\n\nThe coefficient of treat is our estimate of the ATT - the causal effect of treatment on those who receive the treatment. The significance is given by Pr(&gt;|t|) (the p-value) and the stars *** .\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ntreat\nTreatment variable for each observation. Should equal 1 for treated units and 0 for untreated units.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the id variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the id variable.\n\n\n\n\n\nWe can also estimate event-study dynamic effects for pre and post-treatment periods.\n\nSyntaxVariables\n\n\nWe use the feols() function to run the TWFE event study.\n\nmod = feols(\n  fml   = outcome ~ i(rel.time, group, ref = -1) + covar | id + time,  # group = treat/never-treat\n  data  = df,                                                          # your data\n  vcov  = ~ id                                                         # cluster SE by unit\n)\n\nWe can plot these results. The ggiplot() function produces a ggplot2 figure, so any ggplot2 options can be added with a +, including themes, labels, etc.\n\nmod |&gt; ggiplot(\n  xlab    = \"Time Relative to Treatment\",  # x-axis label\n  ylab    = \"Dynamic ATT Estimate\",        # y-axis label\n  main    = \"Dynamic Treatment Effects\",   # title for plot\n) +\n  xlim(-8, 8) # select how many periods to display\n\n\n\n\n\n\n\n\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ngroup\nVariable specifying if a unit is part of the treatment group or never-treated (control group). For units never receiving treatment, they get value 0, and for units that do end up receiving treatment sometime within the study, they get value 1.\n\n\nrel.time\nA relative time variable that indicates for the given period \\(t\\) of an observation, how many time-periods away did the unit \\(i\\) first get the treatment. For the never-treated observations, set the value to a very large or small number (-1000 is a common choice).\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the id variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the id variable.",
    "crumbs": [
      "twfe (fixest)"
    ]
  },
  {
    "objectID": "bacon.html",
    "href": "bacon.html",
    "title": "bacondecomp",
    "section": "",
    "text": "understanding bias of TWFE in staggered settings\n\nWhen the TWFE estimator is implemented in settings with staggered DiD, the estimated \\(\\hat\\tau\\) of the TWFE estimator can be biased.\nThe reason for this is because in staggered settings, TWFE can be “broken down” (decomposed) into a weighted average of other comparisons (which we call \\(\\hat\\beta\\)).\nThere are two issues with this weighted average of comparisons \\(\\hat\\beta\\):\n\nSome of these comparisons are non-sensical. For example, sometimes some of these \\(\\hat\\beta\\) are calculated with already-treated units being the control group, which should not be the case.\nThe weighting of these \\(\\hat\\beta\\) is non-sensical. In theory, the weighted average should weight each \\(\\hat\\beta\\) by how frequently that comparison occurs. But TWFE actually weights by when each \\(\\hat\\beta\\) occurs in the timeline - early and late \\(\\hat\\beta\\) are given less weights (sometimes negative weights).\n\nThe result? TWFE can be incorrect in staggered settings. Sometimes, TWFE may even get the wrong direction of treatment effect.\n\n# packages needed: \nlibrary(bacondecomp)\n\n\nWe start by breaking down the TWFE into its comparisions \\(\\hat\\beta\\) with bacon decomposition.\n\nSyntaxVariables\n\n\nWe use the bacon() function to implement decomposition of TWFE:\n\ndecomp = bacon(\n  formula   = outcome ~ treat,\n  data      = df,\n  id_var    = \"id\",\n  time_var  = \"time\"\n)\n\ndecomp |&gt; head()  # head() because a lot of comparisons\n\n#&gt;                       type  weight  avg_est\n#&gt; 1 Earlier vs Later Treated 0.14286 -2.45996\n#&gt; 2 Later vs Earlier Treated 0.14286 -8.48458\n#&gt; 3     Treated vs Untreated 0.71429 -2.66575\n#&gt;   treated untreated  estimate     weight                 type\n#&gt; 2      10     99999 -8.827665 0.03896104 Treated vs Untreated\n#&gt; 3       9     99999 -7.787725 0.06926407 Treated vs Untreated\n#&gt; 4       8     99999 -3.986033 0.09090909 Treated vs Untreated\n#&gt; 5       7     99999 -4.629684 0.10389610 Treated vs Untreated\n#&gt; 6       6     99999 -3.274153 0.10822511 Treated vs Untreated\n#&gt; 7       5     99999 -1.531851 0.10389610 Treated vs Untreated\n\n\nWe can see the top output is a summary of the general comparisons, while the bottom output is the top 6 rows of all the individual \\(\\hat\\beta\\) comparisons.\nWe can also see Later vs. Earlier (already) treated is a comparison here, which is nonsensical.\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ntreat\nTreatment variable for each observation. Should equal 1 for treated units and 0 for untreated units.\n\n\n\n\n\n\n\nWe know that any negative weights of any comparisons \\(\\hat\\beta\\) are non-sensical. Thus, we can use the following code to check if there are any negative weights:\n\ndecomp$weight |&gt; min()\n\n#&gt; [1] 0.0004329004\n\n\nWe can see in this example, we do not have a negative weight. However, if you do see one, it likely indicates that TWFE is likely very inaccurate in estimating the ATT, and you should use another estimator.\n\nWe can also plot the estimates and weights of all the comparisons.\n\nlibrary(ggplot2)\n\ndecomp |&gt;\n  ggplot(aes(x = weight, y = estimate, shape = type, col = type)) +\n  geom_point() +\n  theme_bw() +\n  labs(\n    x      = \"Weights\",\n    y      = \"Estimates\",\n    shape  = \"Type\",\n    col    = \"Type\",\n    title  = \"Decomposition of TWFE\"\n  )\n\n\n\n\n\n\n\n\nThe green highlighted comparisons all involve earlier (already) treated units being used as control units, which is nonsensical. Bacon decomposition thus shows us the perils of relying on TWFE for staggered treatment.\n\nAdditional Resources\nGoodman-Bacon, A. (2021) ‘Difference-in-Differences with variation in treatment timing’, Journal of Econometrics, 225(2), pp. 254-277. Available at: https://www.nber.org/papers/w25018",
    "crumbs": [
      "bacondecomp"
    ]
  },
  {
    "objectID": "sunab.html",
    "href": "sunab.html",
    "title": "sunab (fixest)",
    "section": "",
    "text": "staggered, absorbing, binary treatment\n\nThe interaction-weighted (IW) estimator, also called sunab, is used for DiD with staggered treatment. The estimator solves the bias of TWFE in staggered settings.\nThe estimator essentially runs smaller event study DiDs for each different initial treatment period grouping. This is done by interactions in the TWFE model.\n\\[\nY_{it} = \\alpha_i + \\delta_t + \\underbrace{\\sum_g \\sum_{r ≠ -1} 1\\{G_i = g\\} \\cdot 1\\{R_{it} = r\\} \\cdot \\tau_{gr}}_\\text{comparisons for each group g and rel.time r} + \\cov + \\eps_{it}\n\\]\n\n\\(G_i\\) is a categorical variable that describes which initial treatment period unit \\(i\\) received treatment. \\(R_{it}\\) is a relative-time variable. Essentially, IW is estimating dynamic treatment effects for each initial treatment period group \\(g\\).\n\nThen, these individual event-study estimates \\(\\tau_{g, r}\\) for each group are aggregated to obtain an overall ATT or dynamic ATTs.\n\n# packages needed:\nlibrary(fixest)\nlibrary(ggfixest)\n\n\n\nSyntaxVariablesNotes\n\n\nWe use the feols() function and the sunab() function to run the matching process of sunab:\n\nmod = feols(\n  fml = outcome ~ sunab(cohort, time) + covar | id + time,\n  data = df,\n  vcov = ~ id\n)\n\nThis completes the matching process. We then need to aggregate to obtain the treatment effects.\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\ncohort\nThis variable indicates the initial year of treatment adoption for each unit. For the never-treated, we should set the value of cohort to a very large positive/negative value that is outside the range of time.\n\n\n\n\n*For repeated cross-section, the id variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the id variable.\n\n\n\nThe variable cohort should be of the following:\n\nUnits that get treated at any time period, should have a cohort value of that initial treatment period.\nUnits that never get treated at any time, should have a very large/small cohort value that is not one of the time fixed effects.\n\nEnsure that cohort is not equal to NA for the never-treated (control) group. This will cause inaccurate estimation.\n\n\n\n\nAfter completing the matching process, we can aggregate our effects into an overall ATT, dynamic ATTs, and cohort-ATTs.\n\nATTDynamicGroup\n\n\nWe use the aggregate() function to aggregate our matched treatment effects into an overall treatment effect.\n\nmod |&gt;\n  aggregate(agg  = \"att\") |&gt;\n  print()\n\n#&gt;      Estimate Std. Error   t value     Pr(&gt;|t|)\n#&gt; ATT -1.133749  0.2050705 -5.528584 2.882038e-07\n\n\nWe can see the estimated ATT in the output table, as well as the estimated p-value in Pr(&gt;|t|).\n\n\nWe can plot the dynamic treatment effects using the IW object estimated when running the model:\n\nmod |&gt; ggiplot(\n  xlab    = \"Time Relative to Treatment\",       # x-axis label\n  ylab    = \"Dynamic ATT Estimate\",             # y-axis label\n  main    = \"Dynamic Treatment Effects (IW)\",   # title for plot\n) + \n  xlim(-8, 8) # how many periods to include.\n\n\n\n\n\n\n\n\n\n\nIf we are interested in how the ATT differs by year of treatment adoption, we can also aggregate effects by initial treatment period group.\n\ngroup = mod |&gt;\n  aggregate(agg = \"cohort\")\n\nThere isn’t a quick way to immediately plot these estimates, but we can manually create a ggplot:\n\n# make group a df\ngroup = group |&gt; as.data.frame()\n\n# add cohort period to group df\ngroup$period = group |&gt; rownames()\ngroup$period = group$period |&gt; as.factor()\n\n# calculate lower and upper conf intervals\ngroup$lower = group$Estimate - 1.96*group$`Std. Error`\ngroup$upper = group$Estimate + 1.96*group$`Std. Error`\n\n# ggplot\ngroup |&gt;\n  ggplot(aes(x = Estimate, y = period)) +\n  geom_vline(xintercept = 0, color = \"red\", linetype = 3) +  # vertical line at 0 treatment effect\n  geom_point() +  # plot the treatment effects\n  geom_linerange(aes(xmin = lower, xmax = upper), width = 0.2) +  # conf intervals\n  labs(title = \"Treatment Effects by Initial Treatment Period\") +  # title (optional)\n  xlab(\"Estimated ATT (IW)\") + ylab(\"Initial Treatment Period\") +  # x-axis and y-axis labels (optional)\n  theme_bw() # theme (optional, change to your liking)\n\n\n\n\n\n\n\n\n\n\n\n\nAdditional Resources\nSun, L. and Abraham S. (2021) ‘Estimating Dynamic Treatment Effects in Event studies with Heterogenous Treatment Effects’, Journal of Econometrics, 225(2), pp. 175-199. Available at: https://arxiv.org/abs/1804.05785\nAdditional Links:\n\nFixest documentation for sunab() function.\nFixest documentation for aggregate() function.\nAsjad Naqvi page on sunab.",
    "crumbs": [
      "sunab (fixest)"
    ]
  },
  {
    "objectID": "csdid.html",
    "href": "csdid.html",
    "title": "csdid (did)",
    "section": "",
    "text": "staggered, absorbing, binary treatment\n\nThe doubly-robust DiD estimator, also called csdid, is an estimator for DiD that solves the issues with TWFE in staggered settings.\nThe estimator essentially runs smaller event study DiDs for each different initial treatment period grouping. It does this by separating all treated units into groups, grouped by their initial treatment year. Then, it compares each group to the never-treated units, calculating dynamic effects \\(\\tau_{g,t}\\) for each group.\n\nThese effects are calculated with adjusted regression, inverse probability weighting, or both combined (called “doubly robust”). Doubly-robust is the default, and should be used unless there are issues.\n\nThe event-study \\(\\tau_{g,t}\\) estimates for each group can be aggregated into the overall ATT, Dynamic ATT’s with all groups combined together, and the overall ATT for each group \\(g\\) separately.\n\n# packages needed:\nlibrary(did)\n\n\n\nSyntaxVariablesNotes\n\n\nWe use the att_gt() function to run the matching process of csdid:\n\nmod = att_gt(\n  # required arguments\n  yname                   = \"outcome\",\n  tname                   = \"time\",\n  idname                  = \"id\",            # must be a integer-variable\n  gname                   = \"cohort\",\n  est_method              = \"dr\",            # change to ipw if you are having issues\n  base_period             = \"universal\",     # do not change\n  allow_unbalanced_panel  = T,               # generally good to keep this T\n  data                    = df,\n  \n  # optional arguments\n  xformla                 = ~ covar,          # include like formula for regression\n  control_group           = \"nevertreated\",  # use \"notyettreated\" if sample size is small\n  panel                   = T                # change to F if you are using rep. cross-section\n)\n\nThis completes the matching process. We then need to aggregate to obtain the treatment effects.\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.* For csdid, this must be integers.\nFor repeated cross section data, you do not need this variable.\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\nfirst.treat\nThis variable indicates the initial year of treatment adoption for each unit. For the never-treated, we should set the value of first.treat to a very large positive/negative value that is outside the range of time.\n\n\n\n\n*For repeated cross-section, the id variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the id variable.\n\nNote for csdid, the id variable must be an integer, not a character variable. You can ensure it is an integer with the following code:\n\ndf$id = as.integer(as.factor(df$id))\n\n\n\nFor csdid, the unit variable must be an integer, not a character variable. You can ensure it is an integer with the following code:\n\ndf$id = as.integer(as.factor(df$id))\n\nThe argument panel = should be set to F if you are using repeated-cross section data. This will automatically turn off the idname = argument as well.\nIf your sample size is small, set the argument control_group = to \"notyettreated\".\nIf you are having issues with irreversable matrices and collinearity, change est_method = to \"ipw\". This will use the inverse probability weighting estimation method only.\nResearch has shown that there are issues if base_period = is not set to \"universal\", so do not change this.\nThe argument allow_unbalanced_panel = essentially allows for some units to have observations not in all time periods. Allowing this to be true will increase sample size. However, we should ask why some units do not have observations in certain years.\n\n\n\n\nAfter completing the matching process, we can aggregate our effects into an overall ATT, dynamic ATTs, calendar ATTs, and cohort-ATTs.\n\nATTDynamicCohortCalendar\n\n\nWe use the aggte() function to aggregate our matched treatment effects into an overall treatment effect.\n\nmod |&gt;\n  aggte(type  = \"simple\", na.rm = T) |&gt;\n  summary(att)\n\n#&gt; \n#&gt; Call:\n#&gt; aggte(MP = mod, type = \"simple\", na.rm = T)\n#&gt; \n#&gt; Reference: Callaway, Brantly and Pedro H.C. Sant'Anna.  \"Difference-in-Differences with Multiple Time Periods.\" Journal of Econometrics, Vol. 225, No. 2, pp. 200-230, 2021. &lt;https://doi.org/10.1016/j.jeconom.2020.12.001&gt;, &lt;https://arxiv.org/abs/1803.09015&gt; \n#&gt; \n#&gt; \n#&gt;      ATT    Std. Error     [ 95%  Conf. Int.]  \n#&gt;  -1.1237        0.5054    -2.1142     -0.1332 *\n#&gt; \n#&gt; \n#&gt; ---\n#&gt; Signif. codes: `*' confidence band does not cover 0\n#&gt; \n#&gt; Control Group:  Never Treated,  Anticipation Periods:  0\n#&gt; Estimation Method:  Doubly Robust\n\n\n\n\nWe can estimate dynamic treatment effects with the aggte() function. We can then plot these effects with the ggdid() function included in the did package:\n\nmod |&gt;\n  aggte(type   = \"dynamic\", na.rm  = T) |&gt;\n  ggdid(\n    xlab    = \"Time to Treatment\",  # x-axis label\n    ylab    = \"Dynamic ATT\",        # y-axis label\n    title   = \"Dynamic Effects\"     # you can include a title string if you want\n  )\n\n\n\n\n\n\n\n\n\n\nIf we are interested in how the ATT differs by year of treatment adoption, we can also aggregate effects by initial treatment period group. We can then plot these effects with the ggdid() function:\n\nmod |&gt;\n  aggte(type   = \"group\", na.rm  = T) |&gt;\n  ggdid(\n    xlab    = \"ATT Estimate\",  # x-axis label\n    ylab    = \"Group\",         # y-axis label\n    title   = \"Group ATT\"      # you can include a title string if you want\n  )\n\n\n\n\n\n\n\n\n\n\nWe can also explore how treatment effects change over calendar time (not relative time, but actual time). We can then plot these effects with the ggdid() function:\n\nmod |&gt;\n  aggte(type   = \"calendar\", na.rm  = T) |&gt;\n  ggdid(\n    xlab   = \"Time Period\",      # x-axis label\n    ylab   = \"Estimate\",         # y-axis label\n    title  = \"Calendar Effects\"  # you can include a title string if you want\n  )\n\n\n\n\n\n\n\n\n\n\n\n\nAdditional Resources\nCallaway, B. and Sant’Anna, P. H. C. (2021) ‘Difference-in-Differences with multiple time periods’, Journal of Econometrics, 225(2), pp. 200-230. Available at: https://psantanna.com/files/Callaway_SantAnna_2020.pdf.\nAdditional Links:\n\nLong vignette on the issues with TWFE and the csdid framework.\ndid package documentation for att_gt().\ndid package documentation for aggte().\ndid package documentation for ggdid().\nAsjad Naqvi page on did.",
    "crumbs": [
      "csdid (did)"
    ]
  },
  {
    "objectID": "fect.html",
    "href": "fect.html",
    "title": "fect",
    "section": "",
    "text": "non-staggered or staggered, absorbing or non-absorbing, binary treatment\n\nThe fixed-effects counterfactual estimator (fect) is an estimator that solves the issues with TWFE in staggered settings and non-absorbing treatment.\nFor treated units \\(D_{it} = 1\\), the potential outcome \\(Y_{it}(0)\\) is a counterfactual we do not observe. fect estimates \\(Y_{it}(0)\\), which allows us to compute individual treatment effects \\(\\tau_i\\) and find the ATT:\n\\[\nY_{it}(0) = \\underbrace{\\alpha_i + \\gamma_t}_\\text{fixed effects} + \\cov + \\eps_{it}\n\\]\n\nThis is literally a TWFE model with \\(D_{it} = 0\\), which is the case for potential outcome \\(Y_{it}(0)\\).\n\n\nfect: this is what is described above.\nIFEct (interactive fixed effects counterfactual): This is the above model for \\(Y_{it}(0)\\), but with the inclusion of latent trends. More simply, this allows IFEct to be more robust to minor parallel trends violations.\nMC (matrix completion). This is a machine-learning based approach of estimating \\(Y_{it}(0)\\) that does not rely on fixed-effects. More simply, this allows MC to be more robust to minor parallel trends violations.\n\n\nYou should generally run a FEct model first - and check if parallel trends are met. If parallel trends are violated, you should test IFEct and MC and see if parallel trends are met in those estimators.\n\n\n# packages needed:\nlibrary(fect)\n\n\n\nSyntaxVariablesNotes\n\n\nWe use the fect() function to estimate fect, ifect, and mc models.\n\nmod = fect(\n  # required arguments\n  formula  = outcome ~ treat + covar,  # covar is optional\n  data     = df,\n  index    = c(\"id\", \"time\"),          # unit and time var\n  method   = \"fe\",                     # use \"fe\", \"ife\", or \"mc\"\n  \n  # optional arguments\n  CV       = F,                        # change to T for \"ife\" or \"mc\"\n  se       = T,                        # don't change\n  nboots   = 40,                       # usually you should use 200, larger is slower\n  seed     = 1239                      # any number will work\n)\n\nmod |&gt; print()\n\n#&gt; Call:\n#&gt; fect.formula(formula = outcome ~ treat + covar, data = df, index = c(\"id\", \n#&gt;     \"time\"), CV = F, method = \"fe\", se = T, nboots = 40, seed = 1239)\n#&gt; \n#&gt; ATT:\n#&gt;                              ATT   S.E. CI.lower CI.upper   p.value\n#&gt; Tr obs equally weighted   -1.091 0.4746   -2.022  -0.1611 2.148e-02\n#&gt; Tr units equally weighted -2.964 0.5814   -4.104  -1.8246 3.432e-07\n#&gt; \n#&gt; Covariates:\n#&gt;        Coef    S.E. CI.lower CI.upper p.value\n#&gt; covar 1.004 0.02042   0.9643    1.044       0\n\n\nThe output contains two different ATT estimates. It is typically conventional to use the first one, Tr obs equally weighted, which weights each observation \\(it\\) equally (rather than the second which weights all \\(i\\) equally).\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*fect does not allow for repeated cross-sections.\n\n\n\nThese models do not work with repeated cross-sections, only panel data.\nThe CV = argument is about cross-validiation (from machine learning). This is because for the ife or mc methods, there are a set of tuning parameters that need to be chosen (for ife, this is the number of latent trends, and mc, it is a series of tuning parameters).\n\nThus, for ife or mc, CV = should be set to T for the automatic selection of these tuning parameters.\nFor fe, there are no tuning parameters, so CV can be dropped or set to F.\n\nThe seed = argument ensures reproducable standard errors, as the package uses bootstrap sampling for standard errors.\n\n\n\n\nThe fect package allows for a variety of plotting to illustrate our treatment effects. These options work with fe, ife, or mc. The fect package also contains two additional diagonistics to test for parallel trends\n\nDynamicCalendarIndividualParallel Trends\n\n\nThe fect package allows quick aggregation of dynamic effects through plotting. The plot is a ggplot object, if you want to change or make additions to it.\n\nmod |&gt; plot(\n  start0  = T,                            # don't change\n  main    = \"Dynamic Treatment Effects\",  # title\n  ylab    = \"Estimate\",                   # y-axis label\n  xlab    = \"Time to Treatment\",          # x-axis label\n  xlim    = c(-7, 7)                      # what time periods to include (offset by +1)\n)\n\n\n\n\n\n\n\n\n\n\nWe can explore how treatment effects change over calendar time (not relative time, but actual time).\n\nmod |&gt; plot(\n  start0  = T,                             # don't change\n  type    = \"calendar\",                    # don't change\n  main    = \"Calendar Treatment Effects\",  # title\n  ylab    = \"Estimate\",                    # y-axis label\n  xlab    = \"Time Period\",                 # x-axis label\n  xlim    = c(1, 10)                       # what time periods to include (offset by +1)\n)\n\n\n\n\n\n\n\n\n\n\nWe can also explore the distributions of individual treatment effects by relative time period:\n\nmod |&gt; plot(\n  start0  = T,                               # don't change\n  type    = \"box\",                           # don't change\n  main    = \"Individual Treatment Effects\",  # title\n  ylab    = \"Estimate\",                      # y-axis label\n  xlab    = \"Time to Treatment\",             # x-axis label\n  xlim    = c(-7, 7)                         # what time periods to include (offset by +1)\n)\n\n\n\n\n\n\n\n\n\n\nThe fect package contains tools to more rigorously test the parallel trends assumption.\n\nmod |&gt; plot(\n  start0      = T,                         # don't change\n  type        = \"equiv\",\n  bound       = \"equiv\",\n  pre.period  = c(-4, 0),                  # how many pre-treat coef to test\n  main        = \"Parallel Trends Tests\",   # title\n  ylab        = \"Estimate\",                # y-axis label\n  xlab        = \"Time to Treatment\",       # x-axis label\n  xlim        = c(-7, 7)                   # what time periods to include (offset by +1)\n)\n\n\n\n\n\n\n\n\nAn F-test tests if the joint combination of pre-treatment coefficients is statistically significantly different than 0. Since we do not want the coefficients to be different than 0, we want to get a high p-value and fail to reject the null.\nAn Equivalence (TOST) test tests if the confidence intervals of our pre-treatment coefficients are within 0.36 standard deviations of the outcome variable of 0. Essentially, it tests if there is a substantively significant deviation in parallel trends.\n\n\n\n\nAdditional Resources\nLiu, L., Wang, Y., and Xu, Y. (2024) ‘A Practical Guide to Counterfactual Estimators for Causal Inference with Time-Series Cross-Sectional Data’, American Journal of Political Science, 68(1), pp. 160-176. Available at: https://yiqingxu.org/papers/english/2022_fect/LWX2022.pdf\nBorusyak, K., Jaravel, X., and Spiess, J. (2024) ‘Revisiting Event-Study Designs: Robust and Efficient Estimation’, The Review of Economic Studies, 91(6), pp. 3253-3285. Available at: https://arxiv.org/abs/2108.12419.\nAdditional Links\n\nYiqing Xu’s page on Fect.\nYiqing Xu’s page on Fect plot options.\nR-documentation of the fect package.",
    "crumbs": [
      "fect"
    ]
  },
  {
    "objectID": "didmultiple.html",
    "href": "didmultiple.html",
    "title": "DIDmultiplegtDYN",
    "section": "",
    "text": "non-staggered or staggered, absorbing or non-absorbing, binary or continuous treatment\n\nThe DIDmultiple estimator is an estimator that solves the issues with TWFE in staggered settings and non-absorbing treatment.\nThe estimator focuses on switchers - those units in a certain period who change their treatment status. In a binary treatment setting, the treatment effect at period \\(\\tau_t\\) can be described as:\n\\[\n\\tau_t = \\frac{\\mathbb E[\\Delta Y |\\text{switchers}] - \\mathbb E[\\Delta Y |\\text{non-switchers}]}{\\underbrace{\\mathbb E[\\Delta D |\\text{switchers}]}_\\text{=1 if absorbing treatment}}\n\\]\n\nFor example, a unit that goes from \\(D_{it} = 0\\) to \\(D_{it} = 1\\). DIDmultiple “matches” these switchers to the group that does not switch (so the group of units that stay \\(D_{it} = 0\\)), and estimates the difference in outcomes.\n\nThen, DIDmultiple aggregates these effects into a singular ATT or dynamic effects. The focus on switchers allows DIDmultiple to be applied onto non-binary treatments, including continuous treatments.\n\n# packages needed:\nlibrary(DIDmultiplegtDYN)\n\n\n\nSyntaxVariablesNotes\n\n\nWe use the did_multiplegt_dyn() function to complete the estimation process:\n\nmod = did_multiplegt_dyn(\n  # required arguments\n  df          = df,\n  outcome     = \"outcome\",\n  group       = \"id\",       # Note: group here refers to unit, not first.treat\n  time        = \"time\",\n  treatment   = \"treat\",\n  effects     = 4,          # Number of post-treatment periods dynamic effects\n  placebo     = 4,          # Number of pre-treatment periods of effects\n  \n  # optional arguments\n  controls    = NULL,       # optional, vector (string) of covariates.\n  continuous  = NULL,       # change to 1 if your treatment is true\n  graph_off   = T\n)\n\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the unit variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the unit variable.\n\n\n\nCovariates for conditional parallel trends are possible to include, but they are used differently, and may cause issues.\nThe effects = argument specifies how many post-treatment dynamic effects you want to estimate.\nThe placebo = argument specifies how many pre-treatment period effects you want to estimate to test the parallel trends assumption.\nThe continuous = argument allows for continuous treatment. Sometimes, even when you do not have a continuous treatment, turning this on may solve your issues.\nThe graph_off = argument specifies if you want the command to print the graph that is generated with the estimation process. If you select T, the graph is still created, just not printed.\n\n\n\n\nOur results can be outputted into print form, or into a plot:\n\nPrintPlot\n\n\nWe can print the results from our object from previously:\n\nmod |&gt; print()\n\n#&gt; \n#&gt; ----------------------------------------------------------------------\n#&gt;        Estimation of treatment effects: Event-study effects\n#&gt; ----------------------------------------------------------------------\n#&gt;              Estimate SE      LB CI    UB CI    N   Switchers\n#&gt; Effect_1     -5.04943 0.45371 -5.93869 -4.16017 675 45       \n#&gt; Effect_2     -3.25734 0.49253 -4.22269 -2.29199 580 40       \n#&gt; Effect_3     -2.17826 0.54482 -3.24609 -1.11044 490 35       \n#&gt; Effect_4     -0.03749 0.50608 -1.02940 0.95442  405 30       \n#&gt; \n#&gt; Test of joint nullity of the effects : p-value = 0.0000\n#&gt; ----------------------------------------------------------------------\n#&gt;     Average cumulative (total) effect per treatment unit\n#&gt; ----------------------------------------------------------------------\n#&gt;  Estimate        SE     LB CI     UB CI         N Switchers \n#&gt;  -2.89921   0.38159  -3.64711  -2.15131       780       150 \n#&gt; Average number of time periods over which a treatment effect is accumulated: 2.3333\n#&gt; \n#&gt; ----------------------------------------------------------------------\n#&gt;      Testing the parallel trends and no anticipation assumptions\n#&gt; ----------------------------------------------------------------------\n#&gt;              Estimate SE      LB CI    UB CI   N   Switchers\n#&gt; Placebo_1    0.27204  0.49208 -0.69242 1.23651 580 40       \n#&gt; Placebo_2    -0.72910 0.61928 -1.94287 0.48467 405 30       \n#&gt; Placebo_3    -0.27729 0.55098 -1.35720 0.80262 250 20       \n#&gt; Placebo_4    0.00895  1.00786 -1.96642 1.98433 115 10       \n#&gt; \n#&gt; Test of joint nullity of the placebos : p-value = 0.5860\n#&gt; \n#&gt; \n#&gt; The development of this package was funded by the European Union.\n#&gt; ERC REALLYCREDIBLE - GA N. 101043899\n\n\nThe Estimation of treatment effects: Event-study effects are the post-treatment dynamic effects.\nThe Average cumulative (total) effect per treatment unit is the ATT estimate.\nThe Testing the parallel trends and no anticipation assumptions is the pre-treatment coefficient estimates.\n\n\nWe can plot the dynamic treatment effects in a plot:\n\nlibrary(ggplot2)\n\n# assign plot to plot object\nplot = mod$plot\n\n# get rid of weird line in default plot\nplot$layers[[1]] &lt;- NULL\n\n# customise plot\nplot +\n  labs(title = \"Dynamic Treatment Effects\") +\n  xlab(\"Time to Treatment (t=1)\") + ylab(\"Estimate\") +\n  \n  # lines for treatment time and 0 treatment effect\n  geom_vline(xintercept = 0.5, linetype = 3) +\n  geom_hline(yintercept = 0, linetype = 3, color = \"red\") +\n  theme_classic()\n\n\n\n\n\n\n\n\n\n\n\n\nAdditional Resources\nde Chaisemartin, C. and D’Haultfœuille, X (2024) ‘Difference-in-Differences Estimators of Intertemporal Treatment Effects’, The Review of Economics and Statistics, pp. 1-45. Available at: https://doi.org/10.1162/rest_a_01414.\nde Chaisemartin, C. and D’Haultfœuille, X (2020) ‘Two-Way Fixed Effects Estimators with Heterogenous Treatment Effects’, American Economic Review, 110(9), pp. 2964-2996. Available at: https://www.nber.org/system/files/working_papers/w25904/w25904.pdf.\nAdditional Links:\n\nAsjad Naqvi’s page on DIDmultipleDYN.\nYiqing Xu’s section on DIDmultiple.\nDIDmultiplegtDYN package documentation.",
    "crumbs": [
      "DIDmultiplegtDYN"
    ]
  },
  {
    "objectID": "panelmatch.html",
    "href": "panelmatch.html",
    "title": "PanelMatch",
    "section": "",
    "text": "non-staggered or staggered, absorbing or non-absorbing, binary treatment.\n\nPanelMatch is an estimator for DiD that solves the issues with TWFE in staggered settings and non-absorbing treatment.\nFor every treated unit \\(D_{it}=1\\) in a specific time period \\(t\\), PanelMatch finds a group of untreated units \\(D_{it} = 0\\) in the same time period, that have identical past treatment history in a set number of previous treatment periods.\n\nThe number of pre-treatment history to match on is called the lag. For example, if lag = 4, then treated units are matched to untreated units with the same treatment history in the 4 periods before this period. When lag = 1, PanelMatch is equivalent to DIDmultiple.\n\nThen, PanelMatch compares the outcome of the treated unit compared to the weighted average of the matched untreated units. When there are no covariates, each matched untreated unit is weighted equally in this weighted average. When there are covariates, weighting depends on the mahalanobis distance of covariates.\nThis comparison produces a series of treatment effect estimates (one for each treated unit). These are then properly aggregated together to find the causal effects.\n\n# packages needed:\nlibrary(PanelMatch)\n\n\nPanelMatch requires us to pre-process the data with the PanelData() function:\n\nSyntaxVariablesNotes\n\n\nWe use the PanelData() function to clean our data to fit the later estimation functions.\n\n# PanelMatch dislikes tidyverse df's, so do this:\ndf = df |&gt; as.data.frame()\n\ndf.panel = PanelData(\n  panel.data  = df,        # your data\n  unit.id     = \"id\",    # your unit var (integer only)\n  time.id     = \"time\",    # your time period var (integer only)\n  treatment   = \"treat\",   # your treatment var\n  outcome     = \"outcome\"  # your outcome var\n)\n\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.* For PanelMatch, this must be integers.\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the id variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the id variable.\n\nPanelMatch requires unit to be an integer variable. We can change a non-integer id into an integer by:\n\ndf$id &lt;- as.integer(as.factor(df$id))\n\n\n\nPanelMatch requires unit to be an integer variable. We can change a non-integer id into an integer by:\n\ndf$id &lt;- as.integer(as.factor(df$id))\n\nPanelMatch also dislikes tidyverse data frames, so we want to convert them into base-R data frames before starting.\n\ndf = df |&gt; as.data.frame()\n\n\n\n\n\nNow, we can run the PanelMatch matching process to match based on lag-period pre-history:\n\nSyntaxNotes\n\n\nWe use the PanelMatch() function to complete the matching process.\n\nmatch = PanelMatch(\n  # required arguments\n  lag                = 4,              # number of pre-periods to match treat history\n  panel.data         = df.panel,       # PanelData generated data\n  lead               = c(0:3),         # how many post-treat dynamic effects to estimate\n  qoi                = \"att\",\n  refinement.method  = \"mahalanobis\",  # set to \"none\" if no covaraites\n  match.missing      = T,\n  \n  # optional arguments\n  covs.formula       = ~ covar,        # (optional, can exclude)\n  placebo.test       = T               # (optional, but may cause issues)\n)\n\nThis completes the matching process, but we still need to estimate the treatment effects.\n\n\nConfusingly, the lag and lead are opposites in this package compared to traditional usage in difference-in-differences. Thus, please be careful when defining the lag = and lead = options.\n\nLag refers to periods before the treatment in which to match on.\nLeads refer to periods after the treatment on which to match on.\n\nIf you are not using any covariates, you should change the argument refinement.method = to \"none\". If you do have covariates, it should remain \"mahalanobis\".\n\nThis basically tells PanelMatch what weights to put on different observations when matching, and how to weight certain matches more than others based on the proximity of covariates.\n\nThe placebo test may cause issues, so if there are issues, change placebo.test = to F.\n\n\n\n\nNow the matching process is complete, and aggregating the effects is now possible.\n\nATTPost-TreatmentPre-Treatment\n\n\nTo aggregate all the matched comparisons into a singular ATT, we use the PanelEstimate() function.\n\nmatch |&gt;\n  PanelEstimate(\n    panel.data = df.panel,  # PanelData object\n    pooled     = T,         # tells R to calculate ATT\n    moderator  = NULL       # optional. character string for var to calculate heterogenous effects\n  ) |&gt;\n  print()\n\n#&gt; Point estimates:\n#&gt; [1] -3.617353\n#&gt; Standard errors:\n#&gt; [1] 0.6146023\n\n\nThe Point estimates are the estimated ATT, and the standard errors are provided.\n\n\nWe can estimate dynamic treatment effects with the PanelEstimate() function:\n\nmatch |&gt;\n  PanelEstimate(\n    panel.data = df.panel,  # PanelData object\n    pooled     = F          # tells R to calculate dynamic effects\n  ) |&gt;\n  plot(\n    ylab = \"Estimate\",            # y-axis label\n    xlab = \"Time to Treatment\",   # x-axis label\n    main = \"Dynamic Effects\"      # title of plot\n  )\n\n\n\n\n\n\n\n\n\n\nWe can conduct pre-treatment period placebo tests (pre-treatment effects to test for parallel trends) as well. These are done with the placebo_test() function.\n\nmatch |&gt; placebo_test(\n  panel.data = df.panel,  # PanelData object\n  lag.in     = 4,         # should equal lag in PanelMatch()\n  plot       = T\n)\n\n\n\n\n\n\n\n\nNote: the estimate for the last pre-treatment period (t-1) is always 0, so it is not displayed.\n\n\n\n\nAdditional Resources\nImai, K., Kim, I. S., and Wang, E. (2023) ‘Matching Methods for Causal Inference with Time-Series Cross-Sectional Data’, American Journal of Political Science, 67(3), pp. 587-605. Available at: https://imai.fas.harvard.edu/research/tscs.html.\nAdditional Links:\n\nPackage documentation for PanelMatch.\nYiqing Xu’s section on PanelMatch.",
    "crumbs": [
      "PanelMatch"
    ]
  },
  {
    "objectID": "did2s.html",
    "href": "did2s.html",
    "title": "did2s",
    "section": "",
    "text": "staggered, absorbing, binary treatment\n\nThe 2-stage difference-in-differences (did2s) estimator is an estimator used for staggered treatment. It first uses only treated units \\(D_{it} = 0\\) to estimate the following model:\n\\[\nY_{it} = \\hat\\alpha_i + \\hat\\delta_t + \\mathbf X^\\top_{it}\\hat{\\b\\beta} + \\hat\\eps_{it}\n\\]\nUsing this model, every unit’s \\(Y_{it}(0)\\) can be estimated as:\n\\[\n\\widehat Y_{it}(0) = \\hat\\alpha_i + \\hat\\delta_t + \\mathbf X^\\top_{it}\\hat{\\b\\beta}\n\\]\nWhich allows for the computation of the ATT:\n\\[\n\\tau_\\text{ATT} = \\mathbb E[\\tau_{it}|D_{it} = 1] \\approx \\mathbb E[Y_{it}(1) - \\widehat Y_{it}(0) | D_{it} = 1]\n\\]\n\nTechnically, did2s uses a regression to calculate the ATT in what is called the “second stage”, but the intuition is the same.\n\n\n# packages needed: \nlibrary(did2s)\nlibrary(ggfixest)\n\n\n\nSyntaxVariablesNotes\n\n\nWe use the did2s() function to run the did2s model.\n\nmod = did2s(\n  data          = df,\n  yname         = \"outcome\",\n  first_stage   = ~ covar | id + time,  # if no covar, see notes\n  second_stage  = ~ i(treat),\n  treatment     = \"treat\",\n  cluster_var   = \"id\"                  # clustered se\n)\n\nmod |&gt; summary()\n\n#&gt; OLS estimation, Dep. Var.: outcome\n#&gt; Observations: 950\n#&gt; Standard-errors: Custom \n#&gt;               Estimate   Std. Error  t value   Pr(&gt;|t|)    \n#&gt; treat::0  6.980000e-17 1.450000e-17  4.82432 1.6362e-06 ***\n#&gt; treat::1 -1.091429e+00 4.763818e-01 -2.29108 2.2177e-02 *  \n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; RMSE: 2.0478   Adj. R2: 0.04683\n\n\nThe coefficient of treat::1 is our estimate of the ATT - the causal effect of treatment on those who receive the treatment. The significance is given by Pr(&gt;|t|) (the p-value) and the stars *** .\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ntreat\nTreatment variable for each observation. Should equal 1 for treated units and 0 for untreated units.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the id variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the id variable.\n\n\n\nThe first-stage first_stage = should be in one of two forms:\n\nfirst_stage = ~ covar | id + time if you have covariates.\nfirst_stage = ~ 0 | id + time if you have no covariates.\n\nThe second-stage second_stage = should generally only include the treatment variable within i().\n\nHowever, if you want heterogenous effects, you can interact the treatment variable with another variable: second_stage = i(treat) + i(treat):othervar\n\n\n\n\n\nWe can also estimate event-study dynamic effects for pre and post-treatment periods.\n\nSyntaxVariablesNotes\n\n\nWe still use the did2s() function to run the event study model, but we alter the second-stage of the model. We then use the ggiplot() function to plot our results.\n\nmod = did2s(\n  data          = df,\n  yname         = \"outcome\",\n  first_stage   = ~ covar | id + time,             # if no covar, see notes\n  second_stage  = ~ i(rel.time, ref = -1),  # see notes for group\n  treatment     = \"treat\",\n  cluster_var   = \"id\"                             # clustered se\n)\n\nmod |&gt; ggiplot(\n  xlab    = \"Time Relative to Treatment\",  # x-axis label\n  ylab    = \"Dynamic ATT Estimate\",        # y-axis label\n  main    = \"Dynamic Treatment Effects\",   # title for plot\n) +\n  xlim(-8, 8) # select how many periods to display\n\n\n\n\n\n\n\n\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ngroup\nVariable specifying if a unit is part of the treatment group or never-treated (control group). For units never receiving treatment, they get value 0, and for units that do end up receiving treatment sometime within the study, they get value 1.\n\n\nrel.time\nA relative time variable that indicates for the given period \\(t\\) of an observation, how many time-periods away did the unit \\(i\\) first get the treatment. For the never-treated observations, set the value to a very large or small number (-1000 is a common choice).\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the id variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the id variable.\n\n\n\nThe first-stage first_stage = should be in one of two forms:\n\nfirst_stage = ~ covar | id + time if you have covariates.\nfirst_stage = ~ 0 | id + time if you have no covariates.\n\n\n\n\n\nAdditional Resources\nGardner, J (2021) ‘Two-Stage Difference-in-Differences’. Available at: https://jrgcmu.github.io/2sdd_current.pdf\nAdditional links:\n\nDescription of the did2s estimation process.\nThe R documentation for did2s.\nAsjad Naqvi’s page on did2s.",
    "crumbs": [
      "did2s"
    ]
  },
  {
    "objectID": "impute.html",
    "href": "impute.html",
    "title": "didimputation",
    "section": "",
    "text": "staggered, absorbing, binary treatment\n\ndidimputation is an estimator for DiD that solves the issues with TWFE in staggered settings. It first uses only treated units \\(D_{it} = 0\\) to estimate the following model:\n\\[\nY_{it} = \\hat\\alpha_i + \\hat\\delta_t + \\mathbf X^\\top_{it}\\hat{\\b\\beta} + \\hat\\eps_{it}\n\\]\nUsing this model, every unit’s \\(Y_{it}(0)\\) can be estimated as:\n\\[\n\\widehat Y_{it}(0) = \\hat\\alpha_i + \\hat\\delta_t + \\mathbf X^\\top_{it}\\hat{\\b\\beta}\n\\]\nWhich allows for the computation of the ATT for each treated individual.\n\\[\n\\tau_{it} = Y_{it}(1) - \\widehat Y_{it}(0)\n\\]\n\n# packages needed: \nlibrary(didimputation)\n\n\n\nSyntaxVariablesNotes\n\n\nWe use the did_imputation() function to run the model.\n\nmod = did_imputation(\n  data         = df,\n  yname        = \"outcome\",\n  gname        = \"cohort\",\n  tname        = \"time\",\n  idname       = \"id\",\n  first_stage  = ~ covar | id + time  # can delete entire arg if no covars\n)\n\nmod |&gt; print()\n\n#&gt; # A tibble: 1 × 6\n#&gt;   lhs     term  estimate std.error conf.low conf.high\n#&gt;   &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 outcome treat    -1.09     0.127    -1.34    -0.842\n\n\nThe estimate is our ATT estimate.\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncohort\nThis variable indicates the initial year of treatment adoption for each unit. For the never-treated, we should set the value of cohort to a very large positive/negative value that is outside the range of time.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the id variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the id variable.\n\n\n\nIf you have no covariates, then you can completely delete the first_stage = argument. The function will automatically include unit and time fixed effects if this argument is not specified.\nIf you do have covariates, include the covariate along with unit and time fixed effects in the first_stage = argument as displayed in the syntax.\n\n\n\n\nWe can also estimate event-study dynamic effects for pre and post-treatment periods.\n\nSyntaxVariables\n\n\n\nmod = did_imputation(\n  data         = df,\n  yname        = \"outcome\",\n  gname        = \"cohort\",\n  tname        = \"time\",\n  idname       = \"id\",\n  first_stage  = ~ covar | id + time,  # can delete entire arg if no covars\n  horizon = T,                         # do not change\n  pretrends = -4:-1                    # how many pre-treatment period to include\n)\n\nThere is no simple way to plot this, so we will have to manually do so.\n\nlibrary(tidyverse)\n\n# convert output into table\ntbl = mod |&gt; as.data.table()\n\n# filter for only treatment coefficients\ntbl$term = tbl$term |&gt; as.numeric()\ntbl = tbl |&gt; na.omit()\n\n# ggplot\ntbl |&gt;\n  ggplot(aes(x = term, y = estimate)) +\n  geom_vline(xintercept = -0.5, linetype = 3) +  # vertical line at treatment +\n  geom_hline(yintercept = 0) +  # horizontal line at 0 effect\n  geom_point() +  # plot treatment effects\n  geom_linerange(aes(ymin = conf.low, ymax = conf.high), width = 0.2) +  # conf intervals\n  labs(title = \"Dynamic Treatment Effects\") +\n  xlab(\"Time to Treatment\") +\n  ylab(\"Estimate\") +\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncohort\nThis variable indicates the initial year of treatment adoption for each unit. For the never-treated, we should set the value of cohort to a very large positive/negative value that is outside the range of time.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the id variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the id variable.",
    "crumbs": [
      "didimputation"
    ]
  },
  {
    "objectID": "etwfe.html",
    "href": "etwfe.html",
    "title": "etwfe",
    "section": "",
    "text": "staggered, absorbing, binary treatment\n\nThe extended two-way fixed effects (etwfe) estimator is an estimator used for staggered treatment.\nThe estimator essentially runs smaller event study DiDs for each different initial treatment period grouping. It also interacts all of these smaller event study variables with confounders.\nBy interacting so many variables together, the estimator captures all the possible heterogeneity in our study. Then, these heterogenous effects are all weighted together based on how frequent each heterogenous effect occurs. This allows the obtaining of ATT or dynamic causal estimates.\n\n# packages needed: \nlibrary(etwfe)\n\n\n\nSyntaxVariables\n\n\nWe use the etwfe() function to first conduct all the interactions and estimation of heterogeneity.\n\nmod = etwfe(\n  fml     = outcome ~ covar,  # see notes for no covar\n  tvar    = time,\n  gvar    = cohort,\n  data    = df,\n  vcov    = ~ id,\n  family  = NULL              # can change to \"logit\", \"negbin\", \"poisson\"\n)\n\nThis completes all the interacting and matching, but we still need to aggregate the effects.\n\n\nOur dataset df should be a panel or repeated cross-section, and have the following variables:\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nid\nA variable indicating the units/individual an observation belongs to in our data.*\n\n\ntime\nA variable indicating time-periods in our study for each observation.\n\n\noutcome\nOutcome variable for each observation.\n\n\ncohort\nThis variable indicates the initial year of treatment adoption for each unit. For the never-treated, we should set the value of cohort to a very large positive/negative value that is outside the range of time.\n\n\ncovar\n(optional) covariate(s) to condition for parallel trends.\n\n\n\n\n*For repeated cross-section, the id variable should be instead the group/level of which treatment is assigned. For example, if treatment is assigned by county/state, use that as the id variable.\n\n\n\n\n\nAfter completing the matching process, we can aggregate our effects into an overall ATT, dynamic ATTs, and cohort-ATTs.\n\nATTDynamicCohortCalendar\n\n\nWe can use the emfx() function to aggregate our heterogenous effects into a singular ATT.\n\nmod |&gt; emfx(type = \"simple\")\n\n#&gt; \n#&gt;  .Dtreat Estimate Std. Error     z Pr(&gt;|z|)    S 2.5 % 97.5 %\n#&gt;     TRUE    -1.21      0.148 -8.23   &lt;0.001 52.2  -1.5 -0.925\n#&gt; \n#&gt; Term: .Dtreat\n#&gt; Type:  response \n#&gt; Comparison: TRUE - FALSE\n\n\nThe estimate for TRUE is our ATT, and the p-value is given by Pr(&gt;|Z|).\n\n\nWe can use the emfx() function to aggregate dynamic treatment effects. We can then plot these effects with the plot() function.\n\nmod |&gt;\n  emfx(type = \"event\") |&gt;\n  plot()\n\n\n\n\n\n\n\n\nNote that etwfe cannot estimate pre-treatment effects.\n\n\nIf we are interested in how the ATT differs by year of treatment adoption, we can also aggregate effects by initial treatment period group. We can then plot these effects with the plot() function:\n\nmod |&gt;\n  emfx(type = \"group\") |&gt;\n  plot()\n\n\n\n\n\n\n\n\n\n\nWe can also explore how treatment effects change over calendar time (not relative time, but actual time). We can then plot these effects with the plot() function:\n\nmod |&gt;\n  emfx(type = \"calendar\") |&gt;\n  plot()\n\n\n\n\n\n\n\n\n\n\n\n\nAdditional Resources\nWooldridge, J. (2021) ‘Two-Way Fixed Effects, the Two-Way Mundlak Regression, and Difference-in-Differences Estimators’. Available at: https://dx.doi.org/10.2139/ssrn.3906345\nWooldridge, J. (2023) ‘Simple approaches to nonlinear difference-in-differences with panel data’, The Econometrics Journal, 26(3), pp. 31-66. Available at: https://academic.oup.com/ectj/article/26/3/C31/7250479?login=false\nAdditional Links:\n\nGrant McDermott’s vignette on etwfe.\nR documentation of the etwfe package.",
    "crumbs": [
      "etwfe"
    ]
  },
  {
    "objectID": "fixest.html",
    "href": "fixest.html",
    "title": "fixest",
    "section": "",
    "text": "versatile package for regression and panel analysis\n\nfixest is arguably the most useful package for an econometrician working with panel data. It can be used to:\n\nRun all sorts of regressions, including fixed effects, IV, generalised linear model, and so on.\nProduce professional visualisations for publications, such as regression tables and plots.\nOther quality of life features for an econometrician.\n\n\n# packages needed: \nlibrary(fixest)\nlibrary(ggfixest)\n\n\nRunning regressions in fixest is mainly done with the feols() function. fixest allows for a variety of standard error specifications, as well as a versatile selection of different regression specifications (see below).\n\nmod = feols(\n  fml   = outcome ~ treat + covar | id + time,  # see below for more on fml\n  data  = df,\n  se    = \"cluster\"                             # \"standard\", \"hetero\", \"cluster\", \"twoway\"\n)\n\n\nfml OptionsNon-linear ModelsStandard Errors\n\n\nfixest accomodates fixed effects and instruments.\n\nStandard: fml = Y ~ D + X1 + X2\nOne-way fixed effects: fml = Y ~ D + X1 + X2 | id\nTwo-way fixed effects: fml = Y ~ D + X1 + X2 | id + time\nInstrumental variables: fml = Y ~ 1 | D ~ Z\nIV with controls: fml = Y ~ X1 + X2 | D ~ Z\nIV with fixed effects: fml = Y ~ 1 | id + time | D ~ Z\n\nfixest also has ways to make categorical variables: fml = Y ~ i(X, ref = 0)\n\nHere X is a categorical variable with a reference category of 0.\n\n\n\nfixest also includes non-linear models. They can be estimated by replacing the feols() function with other functions (with the same syntax):\n\nPoisson regression: fepois()\nNegative binomial: fenegbin()\nLogistic: femlm() with argument family = \"logit\"\n\n\n\nStandard errors are defined by the se = argument or the vcov = argument.\n\nse = \"standard\" is normal OLS standard errors. This is default, so you can drop this argument.\nse = \"hetero\" estimates heteroscedasticity-robust standard errors.\nse = \"cluster\" estimates clustered standard errors by the 1st fixed effect (always the first listed one in the formula).\nse = \"twoway\", \"threeway\", \"fourway\" are also possible with fixed effects.\n\nYou can also use vcov = ~ id to implement clustered standard errors (replace id with the variable to be clustered by). This removes ambiguity of the order of the formula fixed effects.\n\n\n\n\nThe standard way to display results is to use the summary() function. This provides information on coefficients, significance tests, RMSE, R^2, and other metrics.\n\nmod |&gt; summary()\n\n#&gt; OLS estimation, Dep. Var.: outcome\n#&gt; Observations: 950\n#&gt; Fixed-effects: id: 95,  time: 10\n#&gt; Standard-errors: Clustered (id) \n#&gt;       Estimate Std. Error  t value  Pr(&gt;|t|)    \n#&gt; treat -3.68310   0.361071 -10.2005 &lt; 2.2e-16 ***\n#&gt; covar  1.01833   0.032416  31.4142 &lt; 2.2e-16 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; RMSE: 1.60906     Adj. R2: 0.691054\n#&gt;                 Within R2: 0.623425\n\n\nFixest has options to present these results more professionally, as well as ways to extract the results for your own tables/visualisations.\n\nTablePlotExtract\n\n\nYou can create a R-displayed estimation table with esttable(). The esttex() command has the same syntax, but creates a latex table which is well formatted and almost ready to include in a publication.\n\nesttable(\n  mod,                # you can also include a list of multiple models to include in a table\n  se.below      = T,\n  digits        = 3,  # digits for coefs and se\n  digits.stats  = 4,  # digits for R^2\n  title         = \"TWFE Estimates\",\n  dict          = c(                 # dict renames the var names to more presentable names\n    treat   = \"Treatment\",\n    outcome = \"Outcome\",\n    covar   = \"Covariate\"\n  )\n)\n\n#&gt;                      mod\n#&gt; Dependent Var.:  Outcome\n#&gt;                         \n#&gt; Treatment       -3.68***\n#&gt;                 (0.361) \n#&gt; Covariate        1.02***\n#&gt;                 (0.032) \n#&gt; Fixed-Effects:  --------\n#&gt; id                   Yes\n#&gt; time                 Yes\n#&gt; _______________ ________\n#&gt; S.E.: Clustered   by: id\n#&gt; Observations         950\n#&gt; R2                0.7252\n#&gt; Within R2         0.6234\n#&gt; ---\n#&gt; Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nThe latex version looks much better. You can export automatically to a .tex file by using the esttex() with the same syntax, and including the following additional arguments.\n\nfile = \"doc.tex\",  # file name to save to\nreplace = T        # overwrite the existing file?\n\n\n\nWe can plot coefficients with native fixest command coefplot(), or the ggfixest command ggcoefplot() (which produces a ggplot).\n\nmod |&gt; ggcoefplot(\n  xlab    = \"Coefficients\",       # x-axis label\n  ylab    = \"Estimate\",           # y-axis label\n  main    = \"Coefficient Plot\",   # title for plot\n)\n\n\n\n\n\n\n\n\nIf you use ggcoefplot(), the produced ggplot can be modified by any ggplot function, including themes.\niplot() and ggiplot() also work, and they only plot categorical variables. We saw the use of these commands in the TWFE section.\n\n\nYou can extract the values of the estimates directly from our fixest ouput object. This allows us to directly build visualisations.\nWe can extract the coefficient table with coeftable(), which can be turned into a dataframe with as.data.frame(), allowing us to subset and manipulate it.\n\nmod |&gt; coeftable() |&gt; as.data.frame()\n\n#&gt;        Estimate Std. Error   t value     Pr(&gt;|t|)\n#&gt; treat -3.683101 0.36107108 -10.20049 6.895802e-17\n#&gt; covar  1.018332 0.03241625  31.41424 1.211973e-51\n\n\nWe can also extract the coefficients, standard errors, and p-values alone:\n\nmod |&gt; coef()    # coefficients\nmod |&gt; se()      # standard errors\nmod |&gt; pvalue()  # p-values\n\n#&gt;     treat     covar \n#&gt; -3.683101  1.018332 \n#&gt;      treat      covar \n#&gt; 0.36107108 0.03241625 \n#&gt;        treat        covar \n#&gt; 6.895802e-17 1.211973e-51\n\n\nInstead of manually calculating confidence intervals, we can also extract them with confint():\n\nmod |&gt; confint() |&gt; as.data.frame()\n\n#&gt;            2.5 %    97.5 %\n#&gt; treat -4.4000165 -2.966186\n#&gt; covar  0.9539689  1.082695\n\n\n\n\n\n\nWe can also predict fitted values and new values with R.\n\nmod |&gt;\n  predict(newdata = df) |&gt; # put the df with ind var to predict y for\n  head()\n\n#&gt; [1]  4.58668254 -0.61997725  4.45922710  0.08203512 -4.14712849 -1.45323570\n\n\n\nSee fixest documentation for more information.",
    "crumbs": [
      "fixest"
    ]
  }
]